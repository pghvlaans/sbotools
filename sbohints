#!/usr/bin/perl
#
# vim: ts=4:noet
#
# sboconfig
# script to modify the blacklist and optional dependencies
#
# authors: Jacob Pipkin <j@dawnrazor.net>
#          Luke Williams <xocel@iquidus.org>
#          Andreas Guldstrand <andreas.guldstrand@gmail.com>
# maintainer: K. Eugene Carlson <kvngncrlsn@gmail.com>
# license: MIT License

use 5.16.0;
use strict;
use warnings FATAL => 'all';
use SBO::Lib qw/ get_optional lint_sbo_config on_blacklist open_fh open_read prompt script_error show_version uniq usage_error wrapsay %config $conf_dir @listings $tempdir /;
use File::Basename;
use Getopt::Long qw(:config no_ignore_case_always bundling);
use File::Copy;
use File::Temp qw(tempfile);

my $self = basename($0);

sub show_usage {
	print <<"EOF";
Usage: $self [options] [arguments]

Options:
  -h|--help:
    this screen.
  -v|--version:
    version information.
  -l|--list:
    show current blacklist and optional dependencies.
  -q|--query:
    show the hint status of one or more scripts
  -b|--blacklist:
    add scripts to the blacklist (remove with r).
  -o|--optional:
    add optional dependencies to scripts (remove with r).
  -O|--replace-optional:
    replace all optional dependencies for scripts (remove with r).
  --reset:
    empty the blacklist and optional dependencies.

  -r|--remove:
    remove instead of add.

  Examples:
  $self -b libsystemd sbotools
  $self -rb vifm
  $self -q qemu

This is a work in progress. Optional dependency request modification
is not yet functional.
EOF
}

unless (@ARGV) { show_usage(); exit 0; }

my $hintfile = "$conf_dir/sbotools.hints";

my ($help, $version, $list, $reset, $optional, $replace_optional, $blacklist, $remove, $query);

GetOptions(
	'help|h'              => \$help,
	'version|v'           => \$version,
	'list|l'              => \$list,
	'reset'               => \$reset,
	'optional|o'          => \$optional,
	'replace_optional|O'  => \$replace_optional,
	'remove|r'            => \$remove,
	'query|q'             => \$query,
	'blacklist|b'         => \$blacklist,
);

if ($help) { show_usage(); exit 0; }
if ($version) { show_version(); exit 0; }

lint_sbo_config($self, %config);

if (($blacklist and ($optional or $replace_optional)) or ($optional and $replace_optional)) {
	usage_error("optional, replace_optional and blacklist cannot be used together.");
}

if ($list) { show_list(); exit 0; }
if ($query) { make_query(); exit 0; }

if ($reset) {
	if (prompt("Are you sure you want to remove all scripts from the blacklist and all optional dependency requests?", default => 'no')) {
		wrapsay "Removing the blacklist and all optional depedency requests...";
		reset_all();
	} else {
		exit 0;
	}
}

if ($replace_optional or $optional) {
	unless (@ARGV) { show_usage(); exit 0; }
	for my $target (@ARGV) { prompt_queue($target); }
}

if ($blacklist) {
	unless (@ARGV) { show_usage(); exit 0; }
	for my $target (@ARGV) { alter_blacklist($target); }
}

sub alter_blacklist {
	script_error("alter_blacklist requires an argument.") unless @_;
	my $sbo = shift;
	if ($remove and not on_blacklist($sbo)) {
		wrapsay "$sbo is not on the blacklist.";
		return;
	}
	if (on_blacklist($sbo) and not $remove) {
		wrapsay "$sbo is already on the blacklist.";
		return;
	}
	if ($remove) {
		my @incoming;
		# It is not possible to reach this point unless
		# /etc/sbotools/sbotools.hints exists.
		my ($rfh, $rexit) = open_read($hintfile);
		if ($rexit) {
			warn $rfh;
			exit $rexit;
		}
		wrapsay "Removing $sbo from the blacklist...";
		for my $line (<$rfh>) { push @incoming, $line unless $line =~ m/^\!$sbo$/; }
		close $rfh;
		my ($fh, $exit) = open_fh($hintfile, ">");
		if ($exit) {
			warn $fh;
			exit $exit;
		}
		print {$fh} @incoming;
		close $fh;
	} else {
		mkdir $conf_dir unless -d $conf_dir;
		system(qw/ touch /, $hintfile) unless -f $hintfile;
		my ($fh, $exit) = open_fh($hintfile, ">>");
		if ($exit) {
			warn $fh;
			exit $exit;
		}
		wrapsay "Blacklisting $sbo...";
		print {$fh} "!$sbo\n";
		close $fh;
	}
}

sub make_query {
	unless (@ARGV) { show_usage(); exit 0; }
	my $made_output;
	for my $sbo (@ARGV) {
		print "\n" if $made_output;
		if (on_blacklist($sbo)) {
			say "$sbo is blacklisted.";
			$made_output = 1;
		}
		if (my @optionals = get_optional($sbo)) {
			say "Optional dependency requests for $sbo:";
			wrapsay(join(" ", @optionals));
			$made_output = 1;
		}
	}
}

sub prompt_queue {
	script_error("prompt_queue requires an argument.") unless @_;
	my $sbo = shift;
	my (@incoming, $message);
	my @current = get_optional($sbo);
	$message = "Select one or more scripts to add, or leave blank to skip: ";
	$message = "Select one or more scripts to remove, or leave blank to skip: " if $remove;
	$message = "Enter the new optional dependency list, or leave blank to skip: " if $replace_optional;
	$message = "Proceed with clearing the optional dependency list for $sbo?" if $replace_optional and $remove;

	if (@current) {
		wrapsay "Current optional dependencies for $sbo:";
		wrapsay(join(" ", @current), 1);
		unless ($replace_optional and $remove) {
			if (@incoming = split(" ", prompt($message))) {
				write_hints($sbo, @incoming);
			} else {
				say "Skipping.";
				return;
			}
		} elsif (prompt($message, default => 'no')) {
			write_hints($sbo);
		}
	} elsif ($remove) {
		wrapsay "No optional dependency requests to remove for $sbo.";
		return;
	} elsif (@incoming = split(" ", prompt($message))) {
		write_hints($sbo, @incoming);
	}
}

sub reset_all {
	my @loclistings = @listings;
	my @remaining;
	unless (@loclistings) {
		wrapsay "No blacklist or optional dependency requests found.";
		exit 0;
	}
	my ($rfh, $rexit) = open_read($hintfile);
	if ($rexit) {
		warn $rfh;
		exit $rexit;
	}
	for my $line (<$rfh>) {
		chomp(my $search = $line);
		push @remaining, $line unless grep { /$search/ } @loclistings;
	}
	close $rfh;
	my ($fh, $exit) = open_fh($hintfile, '>');
	if ($exit) {
		warn $fh;
		exit $exit;
	}
	print {$fh} @remaining;
	close $fh;
}

sub show_list {
	my @loclistings = @listings;
	my $message = "The blacklist is empty and no optional dependency requests could be identified.";
	unless (@loclistings) {
		wrapsay $message;
		exit 0;
	}
	my (@candlist, @ineffectuals);
	for my $listing (@loclistings) {
		$listing =~ s/^\!//;
		my @members = split(" ", $listing);
		next if not @members;
		for my $cand (@members) { push @candlist, $cand; }
	}
	unless (@candlist) {
		wrapsay $message;
		exit 0;
	}
	@candlist = uniq @candlist;
	@candlist = sort @candlist;
	my ($wrote_blacklist, $wrote_optional);
	for my $sbo (@candlist) {
		if (on_blacklist($sbo)) {
			wrapsay "The following scripts are blacklisted:" if not $wrote_blacklist;
			say "$sbo";
			$wrote_blacklist = 1;
		}
	}
	for my $sbo (@candlist) {
		if (my @optionals = get_optional($sbo)) {
			say " ";
			say "Optional dependency requests for $sbo:";
			wrapsay(join(" ", @optionals));
			push @ineffectuals, $sbo if on_blacklist($sbo);
			$wrote_optional = 1;
		}
	}
	if (@ineffectuals) {
		@ineffectuals = sort @ineffectuals;
		say " ";
		wrapsay "The following scripts have optional dependency requests, but are blacklisted:";
		wrapsay(join("\n", @ineffectuals));
	}
	wrapsay $message unless $wrote_blacklist or $wrote_optional;
	exit 0;
}

sub write_hints {
	# for debugging
	say join(" ", @_);
	# Hint-writing routine. Can reference sbofind, but will probably
	# need to be fairly different. Blacklist modification and reset
	# are handled separately.
}
