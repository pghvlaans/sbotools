package SBO::Lib::Pkgs;

# vim: ts=2:et

use 5.016;
use strict;
use warnings;

our $VERSION = '3.7';

use SBO::Lib::Util qw/ :const :config build_cmp in elf_links script_error error_code open_read uniq version_cmp /;
use SBO::Lib::Tree qw/ get_sbo_location get_sbo_locations is_local /;
use SBO::Lib::Info qw/ get_orig_build_number get_orig_version get_sbo_build_number get_sbo_version /;

use Exporter 'import';
use POSIX 'strftime';

our @EXPORT_OK = qw{
  get_available_updates
  get_inst_names
  get_installed_cpans
  get_installed_packages
  get_local_outdated_versions
  get_removed_builds
  solib_check
  solib_present
  update_known_solibs

  @native_libs
  @x86_libs
  %old_libs
};

our %EXPORT_TAGS = (
  all => \@EXPORT_OK,
);

=pod

=encoding UTF-8

=head1 NAME

SBO::Lib::Pkgs - Routines for interacting with the Slackware package database.

=head1 SYNOPSIS

  use SBO::Lib::Pkgs qw/ get_installed_packages /;

  my @installed_sbos = get_installed_packages('SBO');

=head1 VARIABLES

=head2 @native_libs

An array with shared objects (solibs) of the native architecture in the C<ldconfig(1)> cache.
It is generated by C<solib_check()> via C<update_known_solibs()> if it is empty at the time
of calling.

=head2 %old_libs

A hash with a per-package list of apparently missing first-order shared object dependencies.
It is generated when running C<solib_check()>.

=head2 @x86_libs

An array with 32-bit shared objects in the C<ldconfig(1)> cache. Used only under the
C<x86_64> architecture, it is generated together with C<@native_libs> by C<update_known_solibs()>.

=head1 SUBROUTINES

=cut

my $pkg_db = '/var/log/packages';
my $script_db = '/var/log/scripts';

our @native_libs;
our @x86_libs;
our %old_libs;

=head2 get_available_updates

  my @updates = @{ get_available_updates() };

C<get_available_updates()> compares version and build number information for
packages installed with the _SBo tag with the local repository. It returns
an array reference to an array of hash references specifying package names,
installed versions and available versions.

=cut

# for each installed sbo, find out whether or not the version or build number in
# the tree is newer, and compile an array of hashes containing those which are.
# Takes BUILD for build number only, VERS for version only and BOTH for both
sub get_available_updates {
    script_error('get_available_updates requires an argument.') unless @_ == 1;

    my $filter = shift;
    my @updates;
    my $pkg_list = get_installed_packages('SBO');

    for my $pkg (@$pkg_list) {
        my $location = get_sbo_location($pkg->{name});
        next unless $location;

        my $version = get_sbo_version($location);
        next unless $version;
        my $bump = get_sbo_build_number($location);
        next unless $bump;
        my $version_needed;
        my $build_needed;
        if ($config{STRICT_UPGRADES} eq 'TRUE' and not is_local($pkg->{name})) {
            $version_needed = version_cmp($version, $pkg->{version}) > 0;
            $build_needed = build_cmp($bump, $pkg->{numbuild}, $version, $pkg->{version}) > 0;
        } else {
            $version_needed = version_cmp($version, $pkg->{version}) != 0;
            $build_needed = build_cmp($bump, $pkg->{numbuild}, $version, $pkg->{version}) != 0;
        }
        if ($filter eq 'VERS') {
            if ($version_needed) {
                push @updates, { name => $pkg->{name}, installed => $pkg->{version}, build => $pkg->{numbuild}, update => $version };
            }
        } elsif ($filter eq 'BUILD') {
          if ($build_needed) {
                push @updates, { name => $pkg->{name}, installed => $pkg->{version}, build => $pkg->{numbuild}, update => $version, bump => $bump };
            }
        } else {
            if ($version_needed or $build_needed) {
                push @updates, { name => $pkg->{name}, installed => $pkg->{version}, build => $pkg->{numbuild}, update => $version, bump => $bump };
            }
        }
    }
    return \@updates;
}

=head2 get_inst_names

  my @names = get_inst_names(get_available_updates());

C<get_inst_names()> returns a list of package names from an array reference, such
as one returned by C<get_available_updates()>.

=cut

# for a ref to an array of hashes of installed packages, return an array ref
# consisting of just their names
sub get_inst_names {
    script_error('get_inst_names requires an argument.') unless @_ == 1;
    my $inst = shift;
    my @installed;
    push @installed, $$_{name} for @$inst;
    return \@installed;
}

=head2 get_installed_cpans

  my (@mods, @defective) = @{ get_installed_cpans() };

C<get_installed_cpans()> returns an array reference to a list of Perl
modules installed from the CPAN and a second array with installed modules
that have missing files. Modules are only fully recognized as installed if all
files in C<.packlist> exist. This is used in C<sboinstall(1)> and
C<sboupgrade(1)> to prevent conflicting installations from the CPAN and
SlackBuilds.

=cut

# return a list of perl modules installed via the CPAN
sub get_installed_cpans {
  my $libdirsuffix = $arch =~ m/64(-|$)/ ? "64" : "";
  my $auto_location = "/usr/local/lib$libdirsuffix/perl5/auto";
  my @contents;
  for my $file (grep { -f $_ } map { "$_/perllocal.pod" } @INC) {
    my ($fh, $exit) = open_read($file);
    next if $exit;
    push @contents, grep {/Module/} <$fh>;
    close $fh;
  }
  my $mod_regex = qr/C<Module>\s+L<([^\|]+)/;
  my (@mods, @defective);
  FIRST: for my $line (@contents) {
    my ($missing, $present);
    my $modname = ($line =~ $mod_regex)[0];
    my $dirname = $modname;
    $dirname =~ s/::/\//g;
    my $packlist = "$auto_location/$dirname/.packlist";
    if (-f $packlist) {
      my ($pfh, $pfexit) = open_read($packlist);
      next FIRST if $pfexit;
      for my $pfline (<$pfh>) {
        $pfline =~ s/\n//;
        unless (-f $pfline or -l $pfline) {
          $missing = 1;
        } else {
          $present = 1;
        }
      }
      unless ($missing) {
        push @mods, $modname;
      } elsif ($present) {
        push @defective, $modname;
      }
      close $pfh;
    }
  }
  return (\@mods, \@defective);
}

=head2 get_installed_packages

  my @packages = @{ get_installed_packages($type) };

C<get_installed_packages()> returns an array reference to a list of installed packages
matching the specified C<$type>. The available types are C<STD> for non-SBo packages,
C<SBO> for in-tree _SBo and _SBocompat32 packages, C<DIRTY> for out-of-tree _SBo packages
and C<ALL> for all.

The returned array reference holds a list of hash references representing
the names, versions and full installed package names of the returned packages.

=cut

# pull an array of hashes, each hash containing the name and version of a
# package currently installed. Gets filtered using STD, SBO, DIRTY or ALL.
sub get_installed_packages {
  script_error('get_installed_packages requires an argument.') unless @_ == 1;
  my $filter = shift;

  # Valid types: STD, SBO
  my (@pkgs, %types);
  foreach my $pkg (glob("$pkg_db/*")) {
    $pkg =~ s!^\Q$pkg_db/\E!!;
    my ($name, $version, $build) = $pkg =~ m#^([^/]+)-([^-]+)-[^-]+-([^-]+)$#
      or next;
    my $numbuild = $build;
    $numbuild =~ s/_SBo(|compat32)$//g ;
    my $created = strftime "%F, %H:%M:%S", localtime((stat "$pkg_db/$pkg")[10]);
    push @pkgs, { name => $name, version => $version, build => $build, numbuild => $numbuild, pkg => $pkg, created => $created };
    $types{$name} = 'STD';
  }

  # If we want all packages, let's just return them all
  return [ map { +{ name => $_->{name}, version => $_->{version}, build=> $_->{build}, numbuild => $_->{numbuild}, pkg => $_->{pkg}, created => $_->{created} } } @pkgs ]
    if $filter eq 'ALL';

  # Otherwise, SlackBuilds with locations can be marked with SBO, and packages with
  # the _SBo tag but no location can be marked with DIRTY
  my @sbos = map { $_->{name} } grep { $_->{build} =~ m/_SBo(|compat32)$/ }
    @pkgs;
  if (@sbos) {
    my %locations = get_sbo_locations(map { s/-compat32//gr } @sbos);
    foreach my $sbo (@sbos) {
      $types{$sbo} = 'DIRTY';
      if ($locations{ $sbo =~ s/-compat32//gr }) {
         $types{$sbo} = 'SBO';
      }
    }
  }
  return [ map { +{ name => $_->{name}, version => $_->{version}, build => $_->{build}, numbuild => $_->{numbuild}, pkg => $_->{pkg}, created => $_->{created} } }
    grep { $types{$_->{name}} eq $filter } @pkgs ];
}

=head2 get_local_outdated_versions

  my @outdated = get_local_outdated_versions($filter);

C<get_local_outdated_versions()> checks installed SBo packages from C<LOCAL_OVERRIDES>.
It returns an array with information about those that have version or build numbers
differing from the local repository or the SlackBuild in C<LOCAL_OVERRIDES>.

This subroutine is used only by C<sbocheck(1)>.

=cut

sub get_local_outdated_versions {
  script_error('get_local_outdated_versions requires an argument.') unless @_ == 1;
  my $filter = shift;
  my @outdated;

  my $local = $config{LOCAL_OVERRIDES};
  unless ( $local eq 'FALSE' or not -d $local ) {
    my $pkglist = get_installed_packages('SBO');
    my @local = grep { is_local($_->{name}) } @$pkglist;

    foreach my $sbo (@local) {
      my $local_location = get_sbo_location($sbo->{name});
      next if not defined $local_location;
      my $orig = get_orig_version($sbo->{name});
      next if not defined $orig;
      my $orig_build_number = get_orig_build_number($sbo->{name});
      my $local_build_number = get_sbo_build_number($local_location);

      if ($filter eq 'VERS') {
        next if not version_cmp($orig, $sbo->{version});
      } elsif ($filter eq 'BUILD' and defined $local_build_number) {
        if (not build_cmp($local_build_number, $sbo->{numbuild}, $orig, $sbo->{version})) {
          next;
        }
      } elsif ($filter eq 'BOTH' and defined $local_build_number) {
        if (not build_cmp($local_build_number, $sbo->{numbuild}, $orig, $sbo->{version}) && not version_cmp($orig, $sbo->{version})) {
          next;
        }
      } else { next; }

      if (defined $orig_build_number and defined $local_build_number) {
        push @outdated, { %$sbo, orig => $orig, intree => $orig_build_number, bump => $local_build_number };
      } else {
        push @outdated, { %$sbo, orig => $orig };
      }
    }
  }

  return @outdated;
}

=head2 get_removed_builds

  my @removed = get_removed_builds();

C<get_removed_builds()> returns an array of SlackBuild names and versions of all out-of-tree
installed packages marked C<_SBo>.

This subroutine is used only by C<sbocheck(1)>.

=cut

# For each installed SlackBuild, find out whether it still exists in the tree
sub get_removed_builds {
    my @removed;
    my $pkg_list = get_installed_packages('DIRTY');

    for my $pkg (@$pkg_list) {
        push @removed, { name => $pkg->{name}, installed => $pkg->{version} };
    }

    return \@removed;
}

=head2 solib_check

  my $solibs_good = solib_check($pkg);

C<solib_check()> takes the name of a package file and checks for the presence of any
required first-order shard object dependencies as based on the C<@native_libs> shared
object array. It returns 1 if all required shared objects appear to be present and 0
otherwise.

Because C<elf_links()> is called (see C<SBO::Lib::Util(3)>), performance is cache-dependent.
For this reason, it is best to call C<solib_check()> for C<SBO> packages only, and not
every package installed to the system.

=cut

sub solib_check {
  script_error("solib_check requires an argument.") unless @_ == 1;
  my $pkg = shift;
  my $is_x86_64 = $arch eq "x86_64" ? 1 : 0;
  update_known_solibs() unless @native_libs;
  my $exit = open(my $fh, "<", "$pkg_db/$pkg") == 0;
  error_code("Opening $pkg_db/$pkg failed.", _ERR_OPENFH) if $exit;
  my ($start_reading, @file_list);
  for my $line (<$fh>) {
    $start_reading = 1 if $line eq "./\n";
    next unless defined $start_reading;
    chomp($line);
    next unless -f -x "/$line" or $line =~ m/\.so(|\.\d+(|\.\d+(|\.\d+)))$/;
    push @file_list, "/$line";
  }
  close $fh;
  undef $fh;
  my (@nonexistent, @shared, @x86_shared);
  for my $file (@file_list) {
    next unless my ($elf_links, @cands) = elf_links($file);
    if ($is_x86_64) {
      push @shared, @cands if $elf_links gt 0;
      push @x86_shared, @cands if $elf_links lt 0;
    } else {
      push @shared, @cands;
    }
  }
  return 1 unless @shared or @x86_shared;
  for my $cand (uniq @shared) {
    next if in $cand, @native_libs;
    push @nonexistent, "\t$cand" unless solib_present($cand, $pkg, @file_list);
  }
  for my $cand (uniq @x86_shared) {
    next if in $cand, @x86_libs;
    push @nonexistent, "\t$cand (x86)" unless solib_present($cand, $pkg, @file_list);
  }
  undef @file_list;
  undef @shared;
  undef @x86_shared;
  if (@nonexistent) {
    $old_libs{$pkg} = join("\n", @nonexistent);
    return 0;
  }
  return 1;
}

=head2 solib_present

  my $solib_present = solib_present($cand_lib, $pkg, @candidate_files);

C<solib_present()> takes the name of the shared object to be checked, the name of
a package file and an array with probable ELF files shipped by that package. It returns 1 if
the shard object appears to be present and 0 if it does not.

Please note that the known shared object array C<@native_libs> (and C<@x86_libs> if running
on the C<x86_64> architecture) is the main source of shard object verification.
C<solib_present()> is called after this first verification step fails. Shared objects
that are neither shipped nor created as symlinks by the package can be missed.

=cut

sub solib_present {
  script_error("solib_present requires more than two arguments.") unless @_ > 2;
  my ($cand_lib, $pkg, @file_list) = @_;
  return 1 if $cand_lib =~ m/^\// and -f $cand_lib;
  my $grep_lib = $cand_lib;
  $grep_lib =~ s/\+/\\+/;
  return 1 if grep { /\/$cand_lib$/ } @file_list;
  my $found_in_script;
  if (-f "$script_db/$pkg") {
    if (open(my $fh, "<", "$script_db/$pkg")) {
      for my $line (<$fh>) {
        next unless $line =~ m/^\( cd .* ; rm -rf $grep_lib \)$/;
        my @link_string = split(" ", $line);
        next unless -l "/$link_string[2]/$link_string[6]";
        $found_in_script = 1;
        last;
      }
      close $fh;
      undef $fh;
    }
    return 1 if defined $found_in_script;
  }
  return 0;
}

=head2 update_known_solibs

  update_known_solibs;

C<update_known_solibs()> takes no arguments. It uses the C<--print-cache> option of
C<ldconfig(1)> to generate an array of known shared objects, C<@native_libs>. On
C<x86_64> systems, it generates C<@x86_libs> as well, an array with 32-bit shared objects.

The script exits in case of C<ldcdonfig> failure. There is no useful return value.

=cut

sub update_known_solibs {
  my @ld_lines = split "\n", `/sbin/ldconfig --print-cache`;
  script_error("Getting the ldconfig cache failed. Exiting.") unless @ld_lines;
  undef @native_libs;
  undef @x86_libs;
  my $is_x86_64 = $arch eq "x86_64" ? 1 : 0;
  for my $line (@ld_lines) {
    next unless $line =~ m/^\s/;
    unless ($is_x86_64) {
      push @native_libs, (split " ", $line)[0];
    } else {
      push @native_libs, (split " ", $line)[0] if $line =~ m/\(libc6,x86-64(\)|, )/;
      push @x86_libs, (split " ", $line)[0] if $line =~ m/\(libc6(\)|, )/;
    }
  }
}

=head1 EXIT CODES

Pkgs.pm subroutines can return the following exit codes:

  _ERR_SCRIPT        2   script or module bug
  _ERR_OPENFH        6   failure to open file handles

=head1 SEE ALSO

SBO::Lib(3), SBO::Lib::Build(3), SBO::Lib::Download(3), SBO::Lib::Info(3), SBO::Lib::Readme(3), SBO::Lib::Repo(3), SBO::Lib::Tree(3), SBO::Lib::Util(3), ldconfig(1)

C<https://refspecs.linuxbase.org/elf/gabi4+/> is a helpful resource about the structure of
ELF files.

=head1 AUTHORS

SBO::Lib was originally written by Jacob Pipkin <j@dawnrazor.net> with
contributions from Luke Williams <xocel@iquidus.org> and Andreas
Guldstrand <andreas.guldstrand@gmail.com>.

=head1 MAINTAINER

SBO::Lib is maintained by K. Eugene Carlson <kvngncrlsn@gmail.com>.

=head1 LICENSE

The sbotools are licensed under the MIT License.

Copyright (C) 2012-2017, Jacob Pipkin, Luke Williams, Andreas Guldstrand.

Copyright (C) 2024-2025, K. Eugene Carlson.

=cut

1;
