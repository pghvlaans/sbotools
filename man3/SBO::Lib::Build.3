.\" -*- mode: troff; coding: utf-8 -*-
.\" Automatically generated by Pod::Man v6.0.2 (Pod::Simple 3.45)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" \*(C` and \*(C' are quotes in nroff, nothing in troff, for use with C<>.
.ie n \{\
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Required to disable full justification in groff 1.23.0.
.if n .ds AD l
.\" ========================================================================
.\"
.IX Title "SBO::Lib::Build 3"
.TH SBO::Lib::Build 3 "Pungenday, The Aftermath 21, 3191 YOLD" "" "sbotools 4.1"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH NAME
SBO::Lib::Build \- Routines for building Slackware packages from SlackBuilds.org.
.SH SYNOPSIS
.IX Header "SYNOPSIS"
.Vb 1
\&  use SBO::Lib::Build qw/ perform_sbo /;
\&
\&  my ($foo, $bar, $exit) = perform_sbo(LOCATION => $location);
.Ve
.SH VARIABLES
.IX Header "VARIABLES"
.ie n .SS %concluded
.el .SS \f(CW%concluded\fP
.IX Subsection "%concluded"
This is a shared hash that contains already\-calculated build queues.
It is used by \f(CWget_build_queue()\fR to reduce wasted time and check for
circular dependencies. Note that \f(CW%concluded\fR is cleared
by \f(CW\*(C`sbotool\*(C'\fR when using the \f(CW\*(C`Refresh\*(C'\fR button.
.ie n .SS $env_tmp
.el .SS \f(CW$env_tmp\fP
.IX Subsection "$env_tmp"
This reflects \f(CW$TMP\fR from the environment, being \f(CW\*(C`undef\*(C'\fR if it is not
set.
.ie n .SS @reverse_concluded
.el .SS \f(CW@reverse_concluded\fP
.IX Subsection "@reverse_concluded"
This is a shared array that tracks scripts with verified
reverse dependency chains; it is used by \f(CWget_full_reverse()\fR to check for
circular reverse dependencies. Note that \f(CW@reverse_concluded\fR is cleared
by \f(CW\*(C`sbofind\*(C'\fR, \f(CW\*(C`sboremove\*(C'\fR and \f(CW\*(C`sbotool\*(C'\fR between results.
.ie n .SS $tempdir
.el .SS \f(CW$tempdir\fP
.IX Subsection "$tempdir"
This is a temporary directory created for sbotools\*(Aq use. It should be
removed when sbotools exits.
.ie n .SS $tmpd
.el .SS \f(CW$tmpd\fP
.IX Subsection "$tmpd"
This is the same as \f(CW$TMP\fR if it is set. Otherwise, it is \f(CW\*(C`/tmp/SBo\*(C'\fR.
.ie n .SS @last_level_reverse
.el .SS \f(CW@last_level_reverse\fP
.IX Subsection "@last_level_reverse"
This is an array containing the last level of reverse dependencies generated
by \f(CW\*(C`sbofind\*(C'\fR with \f(CW\*(C`all\-reverse\*(C'\fR and \f(CW\*(C`top\-reverse\*(C'\fR. It is used only by
\&\f(CW\*(C`sbofind\*(C'\fR.
.ie n .SS @upcoming
.el .SS \f(CW@upcoming\fP
.IX Subsection "@upcoming"
This is a shared, non\-exportable array that contains hashes with the source
files needed by each script in the queue. Each hash drops out of the array
when its corresponding script has been built.
.ie n .SS %warnings
.el .SS \f(CW%warnings\fP
.IX Subsection "%warnings"
This is a shared hash that contains per\-script warnings. Possible warnings
currently include \f(CW\*(C`%README%\*(C'\fR and \f(CW\*(C`nonexistent\*(C'\fR.
.SH SUBROUTINES
.IX Header "SUBROUTINES"
.SS do_convertpkg
.IX Subsection "do_convertpkg"
.Vb 1
\&  my ($name32, $exit) = do_convertpkg($name64);
.Ve
.PP
\&\f(CWdo_convertpkg()\fR runs \f(CW\*(C`convertpkg\*(C'\fR on the package in \f(CW$name64\fR.
.PP
On success, it returns the name of the converted package and an exit status. On
failure, it returns an error message instead of the package name.
.SS do_slackbuild
.IX Subsection "do_slackbuild"
.Vb 1
\&  my ($ver, $pkg, $src, $exit) = do_slackbuild(LOCATION => $location);
.Ve
.PP
\&\f(CWdo_slackbuild()\fR makes checks and sets up the \f(CWperform_sbo()\fR call,
running \f(CWdo_convertpkg()\fR if needed.
.PP
A list of four values is returned if successful: version number, package name,
an array with source directories and an exit code. In case of failure, the first
value is an error message; the second and third values are empty.
.SS do_upgradepkg
.IX Subsection "do_upgradepkg"
.Vb 1
\&  do_upgradepkg($pkg);
.Ve
.PP
\&\f(CWdo_upgradepkg()\fR runs \f(CW\*(C`upgradepkg \-\-reinstall \-\-install\-new\*(C'\fR on \f(CW$pkg\fR.
.PP
There is no useful return value.
.SS get_build_queue
.IX Subsection "get_build_queue"
.Vb 1
\&  my @queue = @{ get_build_queue($sbo, my @checked) };
.Ve
.PP
\&\f(CWget_build_queue()\fR gets the prerequisites for \f(CW$sbo\fR, updating the shared
\&\f(CW$warnings\fR hash reference with any \f(CW\*(C`%README%\*(C'\fR encountered. It returns the
prerequisites and \f(CW$sbo\fR in the correct build order.
.PP
\&\f(CW@checked\fR and \f(CW\*(C`our %concluded\*(C'\fR are used to check for circular dependencies; the
script exits with \f(CW\*(C`_ERR_CIRCULAR\*(C'\fR if any are present.
.SS get_full_queue
.IX Subsection "get_full_queue"
.Vb 1
\&  my @revdep_queue = ($installed, @sbos);
.Ve
.PP
\&\f(CWget_full_queue()\fR takes a list of installed SlackBuilds and an array
of SlackBuilds to check. It returns a list of the checked SlackBuilds and
their dependencies in reverse build order such that no SlackBuild appears
after any of its dependencies.
.SS get_full_reverse
.IX Subsection "get_full_reverse"
.Vb 1
\&  my @get_full_reverse = get_full_reverse($sbo, %installed, %fulldeps, my @checked, my @list)
.Ve
.PP
\&\f(CWget_full_reverse()\fR takes a SlackBuild, a hash of installed packages, a hash
of reverse dependency relationships (from \f(CW\*(C`get_reverse_reqs\*(C'\fR) and two arrays.
These arrays should not be included when called from outside of the subroutine.
\&\f(CWget_full_reverse()\fR returns an array with installed reverse dependencies.
.PP
The final level of reverse dependencies is kept in the shared array \f(CW@last_level_reverse\fR;
these are displayed only by \f(CW\*(C`sbofind \-\-top\-reverse\*(C'\fR.
.PP
If any circular reverse dependencies are found, the script exits with \f(CW\*(C`_ERR_CIRCULAR\*(C'\fR.
.SS get_full_reverse_queue
.IX Subsection "get_full_reverse_queue"
.Vb 2
\&  my (@reverse_queue) = get_full_reverse_queue($from, $updates, $sbo ...)
\&  my (@reverse_queue) = get_full_reverse_queue($from, $self_include, $sbo ...)
.Ve
.PP
\&\f(CWget_full_reverse_queue()\fR takes the name of the script it is called from and any number
of SlackBuilds. The second variable is the list of available upgrades (if called from
\&\fBsboupgrade\|(1)\fR), any true value if called from \fBsboinstall\|(1) \-\-reinstall\fR and a
false value otherwise. The subroutine returns a queue for a reverse dependency rebuild.
.SS get_pkg_name
.IX Subsection "get_pkg_name"
.Vb 1
\&  my $name = get_pkg_name($str);
.Ve
.PP
\&\f(CWget_pkg_name()\fR searches \f(CW$str\fR for text matching the package name output
from \f(CW\*(C`makepkg\*(C'\fR. The package name is returned.
.SS get_src_dir
.IX Subsection "get_src_dir"
.Vb 1
\&  my @dirs = @{ get_src_dir(@orig_dirs) };
.Ve
.PP
\&\f(CWget_src_dir()\fR returns a list of those directories under \f(CW\*(C`/tmp/SBo\*(C'\fR or \f(CW$TMP\fR
that are not in \f(CW@orig_dirs\fR. That is, the source directories for the script.
.SS get_tmp_extfn
.IX Subsection "get_tmp_extfn"
.Vb 1
\&  my ($ret, $exit) = get_tmp_extfn($fh);
.Ve
.PP
\&\f(CWget_tmp_extfn()\fR gets the \f(CW\*(C`/dev/fd/X\*(C'\fR filename for the file handle \f(CW$fh\fR passed
in, setting flats to make it usable from other processes.
.PP
It returns the filename if successful, and \f(CW\*(C`undef\*(C'\fR otherwise.
.SS make_clean
.IX Subsection "make_clean"
.Vb 1
\&  make_clean(SBO => $sbo, SRC => $src, VERSION => $ver);
.Ve
.PP
\&\f(CWmake_clean()\fR removes source, package and compat32 directories left after running
a SlackBuild.
.PP
It has no useful return value.
.SS make_distclean
.IX Subsection "make_distclean"
.Vb 1
\&  make_distclean(SRC => $src, VERSION => $ver, LOCATION => $loc);
.Ve
.PP
\&\f(CWmake_distclean()\fR removes any downloaded source tarballs and the completed package
archive. These files are not removed if they are needed by a script later in the
queue; this is mostly relevant for compat32 and some Rust\-based scripts.
.PP
It has no useful return value.
.SS merge_queues
.IX Subsection "merge_queues"
.Vb 1
\&  my @merged = @{ merge_queues([@queue1], [@queue2]) };
.Ve
.PP
\&\f(CWmerge_queues()\fR takes two array references and merges them such that \f(CW@queue1\fR
is in front, followed by any non\-redundant items in \f(CW@queue2\fR. This is returned
as an array reference.
.SS perform_sbo
.IX Subsection "perform_sbo"
.Vb 1
\&  my ($pkg, $src, $exit) = perform_sbo(LOCATION => $location);
.Ve
.PP
\&\f(CWperform_sbo()\fR prepares and runs a SlackBuild. It returns the package name,
an array with source directories and an exit code if successful. If unsuccessful,
the first value is instead an error message.
.SS process_sbos
.IX Subsection "process_sbos"
.Vb 1
\&  my (@failures, $exit) = process_sbos(TODO => [@queue]);
.Ve
.PP
\&\f(CWprocess_sbos()\fR processes a \f(CW@queue\fR of SlackBuilds and returns an array reference
with failed builds and the exit status.
.PP
In case of a mass rebuild, \f(CW\*(C`process_sbos\*(C'\fR updates the resume file \f(CW\*(C`resume.temp\*(C'\fR
when a build fails.
.SS rationalize_queue
.IX Subsection "rationalize_queue"
.Vb 1
\&  my $queue = rationalize_queue($queue)
.Ve
.PP
\&\f(CWrationalize_queue()\fR takes a build queue and rearranges it such that
no script appears before any of its dependencies. The order is predictable
given the scripts included and favors keeping dependency chains together,
especially beyond the first level; this makes output and build orders more
intuitive.
.PP
Currently, this is only useful when the queue has been constructed with
reference to reverse dependencies, or, in the case of \f(CW\*(C`sbotest\*(C'\fR, a full
repository test or archive rebuild is needed.
.PP
\&\f(CW\*(C`sbotest\*(C'\fR has a separate subroutine that reduces the number of expected
package installations and removals during test runs. Intuitiveness is not
to be expected in \f(CW\*(C`sbotest\*(C'\fR queues.
.PP
The rearranged queue is returned.
.SS run_tee
.IX Subsection "run_tee"
.Vb 1
\&  my ($output, $exit) = run_tee($cmd, $log_name);
.Ve
.PP
\&\f(CWrun_tee()\fR runs \f(CW$cmd\fR under \f(CWtee(1)\fR to display STDOUT and return it as
a string. The second return value is the exit status. If \f(CW\*(C`LOG_DIR\*(C'\fR is set,
STDOUT and STDERR are saved to a timestamped log file named \f(CW$log_name\fR. Otherwise,
STDOUT only is saved to the temporary directory.
.PP
If the bash interpreter cannot be run, the first return value is \f(CW\*(C`undef\*(C'\fR and
the exit status holds a non\-zero value.
.SH "EXIT CODES"
.IX Header "EXIT CODES"
Build.pm subroutines can return the following exit codes:
.PP
.Vb 9
\&  _ERR_SCRIPT        2   script or module bug
\&  _ERR_BUILD         3   errors when executing a SlackBuild
\&  _ERR_OPENFH        6   failure to open file handles
\&  _ERR_NOMULTILIB    9   lacking multilib capabilities when needed
\&  _ERR_CONVERTPKG    10  convertpkg\-compat32 failure
\&  _ERR_NOCONVERTPKG  11  lacking convertpkg\-compat32 when needed
\&  _ERR_INST_SIGNAL   12  the script was interrupted while building
\&  _ERR_CIRCULAR      13  attempted to calculate a circular dependency
\&  _ERR_STDIN         16  reading keyboard input failed
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fBSBO::Lib\fR\|(3), \fBSBO::Lib::Download\fR\|(3), \fBSBO::Lib::Info\fR\|(3), \fBSBO::Lib::Pkgs\fR\|(3), \fBSBO::Lib::Readme\fR\|(3), \fBSBO::Lib::Repo\fR\|(3), \fBSBO::Lib::Solibs\fR\|(3), \fBSBO::Lib::Tree\fR\|(3), \fBSBO::Lib::Util\fR\|(3)
.SH AUTHORS
.IX Header "AUTHORS"
SBO::Lib was originally written by Jacob Pipkin <j@dawnrazor.net> with
contributions from Luke Williams <xocel@iquidus.org> and Andreas
Guldstrand <andreas.guldstrand@gmail.com>.
.SH MAINTAINER
.IX Header "MAINTAINER"
SBO::Lib is maintained by K. Eugene Carlson <kvngncrlsn@gmail.com>.
.SH LICENSE
.IX Header "LICENSE"
The sbotools are licensed under the MIT License.
.PP
Copyright (C) 2012\-2017, Jacob Pipkin, Luke Williams, Andreas Guldstrand.
.PP
Copyright (C) 2024\-2025, K. Eugene Carlson.
