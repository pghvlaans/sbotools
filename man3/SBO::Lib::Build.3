.\" -*- mode: troff; coding: utf-8 -*-
.\" Automatically generated by Pod::Man 5.0102 (Pod::Simple 3.45)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" \*(C` and \*(C' are quotes in nroff, nothing in troff, for use with C<>.
.ie n \{\
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "SBO::Lib::Build 3"
.TH SBO::Lib::Build 3 "Prickle-Prickle, Chaos 14, 3191 YOLD" "" "sbotools 3.4"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH NAME
SBO::Lib::Build \- Routines for building Slackware packages from SlackBuilds.org.
.SH SYNOPSIS
.IX Header "SYNOPSIS"
.Vb 1
\&  use SBO::Lib::Build qw/ perform_sbo /;
\&
\&  my ($foo, $bar, $exit) = perform_sbo(LOCATION => $location, ARCH => \*(Aqx86_64\*(Aq);
.Ve
.SH VARIABLES
.IX Header "VARIABLES"
.ie n .SS @concluded
.el .SS \f(CW@concluded\fP
.IX Subsection "@concluded"
This is a shared, non-exportable array that tracks scripts with verified
completable build queues; it is used by \f(CWget_build_queue()\fR to check for
circular dependencies.
.ie n .SS $env_tmp
.el .SS \f(CW$env_tmp\fP
.IX Subsection "$env_tmp"
This reflects \f(CW$TMP\fR from the environment, being \f(CW\*(C`undef\*(C'\fR if it is not
set.
.ie n .SS @reverse_concluded
.el .SS \f(CW@reverse_concluded\fP
.IX Subsection "@reverse_concluded"
This is a shared, non-exportable array that tracks scripts with verified
reverse dependency chains; it is used by \f(CWget_full_reverse()\fR to check for
circular reverse dependencies.
.ie n .SS $tmpd
.el .SS \f(CW$tmpd\fP
.IX Subsection "$tmpd"
This is the same as \f(CW$TMP\fR if it is set. Otherwise, it is \f(CW\*(C`/tmp/SBo\*(C'\fR.  =head2 \f(CW$tempdir\fR
.PP
This is a temporary directory created for sbotools' use. It should be
removed when sbotools exits.
.SH SUBROUTINES
.IX Header "SUBROUTINES"
.SS do_convertpkg
.IX Subsection "do_convertpkg"
.Vb 1
\&  my ($name32, $exit) = do_convertpkg($name64);
.Ve
.PP
\&\f(CWdo_convertpkg()\fR runs \f(CW\*(C`convertpkg\*(C'\fR on the package in \f(CW$name64\fR.
.PP
On success, it returns the name of the converted package and an exit status. On
failure, it returns an error message instead of the package name.
.SS do_slackbuild
.IX Subsection "do_slackbuild"
.Vb 1
\&  my ($ver, $pkg, $src, $exit) = do_slackbuild(LOCATION => $location);
.Ve
.PP
\&\f(CWdo_slackbuild()\fR makes checks and sets up the \f(CWperform_sbo()\fR call,
running \f(CWdo_convertpkg()\fR if needed.
.PP
A list of four values is returned if successful: version number, package name,
an array with source directories and an exit code. In case of failure, the first
value is an error message; the second and third values are empty.
.SS do_upgradepkg
.IX Subsection "do_upgradepkg"
.Vb 1
\&  do_upgradepkg($pkg);
.Ve
.PP
\&\f(CWdo_upgradepkg()\fR runs \f(CW\*(C`upgradepkg \-\-reinstall \-\-install\-new\*(C'\fR on \f(CW$pkg\fR.
.PP
There is no useful return value.
.SS get_build_queue
.IX Subsection "get_build_queue"
.Vb 1
\&  my @queue = @{ get_build_queue($sbo, my $warnings, my @checked) };
.Ve
.PP
\&\f(CWget_build_queue()\fR gets the prerequisites for \f(CW$sbo\fR, updating the
\&\f(CW$warnings\fR hash reference with any \f(CW\*(C`%README%\*(C'\fR encountered. It returns the
prerequisites and \f(CW$sbo\fR in the correct build order.
.PP
\&\f(CW@checked\fR and \f(CW\*(C`our @concluded\*(C'\fR are used to check for circular dependencies; the
script exits with \f(CW\*(C`_ERR_CIRCULAR\*(C'\fR if any are present.
.SS get_dc_regex
.IX Subsection "get_dc_regex"
.Vb 1
\&  my ($rx, $initial) = get_dc_regex($line);
.Ve
.PP
\&\f(CWget_dc_regex()\fR creates a regular expression that should match the filename
given a line with e.g. an untar command. This is returned together with the \f(CW$initial\fR
character, which starts the filename match.
.SS get_full_queue
.IX Subsection "get_full_queue"
.Vb 1
\&  my @revdep_queue = ($installed, @sbos);
.Ve
.PP
\&\f(CWget_full_queue()\fR takes a list of installed SlackBuilds and an array
of SlackBuilds to check. It returns a list of reverse dependencies.
.SS get_full_reverse
.IX Subsection "get_full_reverse"
.Vb 1
\&  my @get_full_reverse = get_full_reverse($sbo, %installed, %fulldeps, my @checked, my @list)
.Ve
.PP
\&\f(CWget_full_reverse()\fR takes a SlackBuild, a hash of installed packages, a hash
of reverse dependency relationships (from \f(CW\*(C`get_reverse_reqs\*(C'\fR) and an array.
This array should not be included when called from outside of the subroutine.
\&\f(CWget_full_reverse()\fR returns an array with installed reverse dependencies.
.PP
If any circular reverse dependencies are found, the script exits with \f(CW\*(C`_ERR_CIRCULAR\*(C'\fR.
.SS get_pkg_name
.IX Subsection "get_pkg_name"
.Vb 1
\&  my $name = get_pkg_name($str);
.Ve
.PP
\&\f(CWget_pkg_name()\fR searches \f(CW$str\fR for text matching the package name output
from \f(CW\*(C`makepkg\*(C'\fR. The package name is returned.
.SS get_src_dir
.IX Subsection "get_src_dir"
.Vb 1
\&  my @dirs = @{ get_src_dir(@orig_dirs) };
.Ve
.PP
\&\f(CWget_src_dir()\fR returns a list of those directories under \f(CW\*(C`/tmp/SBo\*(C'\fR or \f(CW$TMP\fR
that are not in \f(CW@orig_dirs\fR. That is, the source directories for the script.
.SS get_tmp_extfn
.IX Subsection "get_tmp_extfn"
.Vb 1
\&  my ($ret, $exit) = get_tmp_extfn($fh);
.Ve
.PP
\&\f(CWget_tmp_extfn()\fR gets the \f(CW\*(C`/dev/fd/X\*(C'\fR filename for the file handle \f(CW$fh\fR passed
in, setting flats to make it usable from other processes.
.PP
It returns the filename if successful, and \f(CW\*(C`undef\*(C'\fR otherwise.
.SS make_clean
.IX Subsection "make_clean"
.Vb 1
\&  make_clean(SBO => $sbo, SRC => $src, VERSION => $ver);
.Ve
.PP
\&\f(CWmake_clean()\fR removes source, package and compat32 directories left after running
a SlackBuild.
.PP
It has no useful return value.
.SS make_distclean
.IX Subsection "make_distclean"
.Vb 1
\&  make_distclean(SRC => $src, VERSION => $ver, LOCATION => $loc);
.Ve
.PP
\&\f(CWmake_distclean()\fR removes the same directories as \f(CWmake_clean()\fR does,
as well as distribution files, such as the downloaded source tarballs.
.PP
It has no useful return value.
.SS merge_queues
.IX Subsection "merge_queues"
.Vb 1
\&  my @merged = @{ merge_queues([@queue1], [@queue2]) };
.Ve
.PP
\&\f(CWmerge_queues()\fR takes two array references and merges them such that \f(CW@queue1\fR
is in front, followed by any non-redundant items in \f(CW@queue2\fR. This is returned
as an array reference.
.SS perform_sbo
.IX Subsection "perform_sbo"
.Vb 1
\&  my ($pkg, $src, $exit) = perform_sbo(LOCATION => $location, ARCH => $arch);
.Ve
.PP
\&\f(CWperform_sbo()\fR prepares and runs a SlackBuild. It returns the package name,
an array with source directories and an exit code if successful. If unsuccessful,
the first value is instead an error message.
.SS process_sbos
.IX Subsection "process_sbos"
.Vb 1
\&  my (@failures, $exit) = process_sbos(TODO => [@queue]);
.Ve
.PP
\&\f(CWprocess_sbos()\fR processes a \f(CW@queue\fR of SlackBuilds and returns an array reference
with failed builds and the exit status.
.PP
In case of a mass rebuild, \f(CW\*(C`process_sbos\*(C'\fR updates the resume file \f(CW\*(C`resume.temp\*(C'\fR
when a build fails.
.SS revert_slackbuild
.IX Subsection "revert_slackbuild"
.Vb 1
\&  revert_slackbuild($path);
.Ve
.PP
\&\f(CWrevert_slackbuild()\fR restores a SlackBuild rewritten by
\&\f(CWrewrite_slackbuild()\fR.
.PP
There is no useful return value.
.SS rewrite_slackbuild
.IX Subsection "rewrite_slackbuild"
.Vb 1
\&  my ($ret, $exit) = rewrite_slackbuild(%args);
.Ve
.PP
\&\f(CWrewrite_slackbuild()\fR, when given an argument hash, copies the SlackBuild
at \f(CW$path\fR and rewrites it with the needed changes. The required arguments include
\&\f(CW\*(C`SBO\*(C'\fR (the name of the script), \f(CW\*(C`SLACKBUILD\*(C'\fR (the location of the unaltered
SlackBuild), \f(CW\*(C`CHANGES\*(C'\fR (the required changes) and \f(CW\*(C`C32\*(C'\fR (0 if the build is not
compat32, and 1 if it is).
.PP
On failure, an error message and the exit status are returned. On success, 1 and an exit
status of 0 are returned.
.SS run_tee
.IX Subsection "run_tee"
.Vb 1
\&  my ($output, $exit) = run_tee($cmd);
.Ve
.PP
\&\f(CWrun_tee()\fR runs \f(CW$cmd\fR under \f(CWtee(1)\fR to display STDOUT and return it as
a string. The second return value is the exit status.
.PP
If the bash interpreter cannot be run, the first return value is \f(CW\*(C`undef\*(C'\fR and
the exit status holds a non-zero value.
.SH AUTHORS
.IX Header "AUTHORS"
SBO::Lib was originally written by Jacob Pipkin <j@dawnrazor.net> with
contributions from Luke Williams <xocel@iquidus.org> and Andreas
Guldstrand <andreas.guldstrand@gmail.com>.
.PP
SBO::Lib is maintained by K. Eugene Carlson <kvngncrlsn@gmail.com>.
.SH LICENSE
.IX Header "LICENSE"
The sbotools are licensed under the MIT License.
.PP
Copyright (C) 2012\-2017, Jacob Pipkin, Luke Williams, Andreas Guldstrand.
.PP
Copyright (C) 2024\-2025, K. Eugene Carlson.
