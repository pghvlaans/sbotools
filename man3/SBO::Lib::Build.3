.\" -*- mode: troff; coding: utf-8 -*-
.\" Automatically generated by Pod::Man 5.0102 (Pod::Simple 3.45)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" \*(C` and \*(C' are quotes in nroff, nothing in troff, for use with C<>.
.ie n \{\
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "SBO::Lib::Build 3"
.TH SBO::Lib::Build 3 "Setting Orange, Discord 57, 3191 YOLD" "" "sbotools 3.6"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH NAME
SBO::Lib::Build \- Routines for building Slackware packages from SlackBuilds.org.
.SH SYNOPSIS
.IX Header "SYNOPSIS"
.Vb 1
\&  use SBO::Lib::Build qw/ perform_sbo /;
\&
\&  my ($foo, $bar, $exit) = perform_sbo(LOCATION => $location, ARCH => \*(Aqx86_64\*(Aq);
.Ve
.SH VARIABLES
.IX Header "VARIABLES"
.ie n .SS @concluded
.el .SS \f(CW@concluded\fP
.IX Subsection "@concluded"
This is a shared, non-exportable array that tracks scripts with verified
completable build queues; it is used by \f(CWget_build_queue()\fR to check for
circular dependencies.
.ie n .SS $env_tmp
.el .SS \f(CW$env_tmp\fP
.IX Subsection "$env_tmp"
This reflects \f(CW$TMP\fR from the environment, being \f(CW\*(C`undef\*(C'\fR if it is not
set.
.ie n .SS @reverse_concluded
.el .SS \f(CW@reverse_concluded\fP
.IX Subsection "@reverse_concluded"
This is a shared, non-exportable array that tracks scripts with verified
reverse dependency chains; it is used by \f(CWget_full_reverse()\fR to check for
circular reverse dependencies.
.ie n .SS $tempdir
.el .SS \f(CW$tempdir\fP
.IX Subsection "$tempdir"
This is a temporary directory created for sbotools' use. It should be
removed when sbotools exits.
.ie n .SS $tmpd
.el .SS \f(CW$tmpd\fP
.IX Subsection "$tmpd"
This is the same as \f(CW$TMP\fR if it is set. Otherwise, it is \f(CW\*(C`/tmp/SBo\*(C'\fR.
.ie n .SS @last_level_reverse
.el .SS \f(CW@last_level_reverse\fP
.IX Subsection "@last_level_reverse"
This is an array containing the last level of reverse dependencies generated
by \f(CW\*(C`sbofind\*(C'\fR with \f(CW\*(C`all\-reverse\*(C'\fR and \f(CW\*(C`top\-reverse\*(C'\fR. It is used only by
\&\f(CW\*(C`sbofind\*(C'\fR.
.ie n .SS @upcoming
.el .SS \f(CW@upcoming\fP
.IX Subsection "@upcoming"
This is a shared, non-exportable array that contains hashes with the source
files needed by each script in the queue. Each hash drops out of the array
when its corresponding script has been built.
.SH SUBROUTINES
.IX Header "SUBROUTINES"
.SS do_convertpkg
.IX Subsection "do_convertpkg"
.Vb 1
\&  my ($name32, $exit) = do_convertpkg($name64);
.Ve
.PP
\&\f(CWdo_convertpkg()\fR runs \f(CW\*(C`convertpkg\*(C'\fR on the package in \f(CW$name64\fR.
.PP
On success, it returns the name of the converted package and an exit status. On
failure, it returns an error message instead of the package name.
.SS do_slackbuild
.IX Subsection "do_slackbuild"
.Vb 1
\&  my ($ver, $pkg, $src, $exit) = do_slackbuild(LOCATION => $location);
.Ve
.PP
\&\f(CWdo_slackbuild()\fR makes checks and sets up the \f(CWperform_sbo()\fR call,
running \f(CWdo_convertpkg()\fR if needed.
.PP
A list of four values is returned if successful: version number, package name,
an array with source directories and an exit code. In case of failure, the first
value is an error message; the second and third values are empty.
.SS do_upgradepkg
.IX Subsection "do_upgradepkg"
.Vb 1
\&  do_upgradepkg($pkg);
.Ve
.PP
\&\f(CWdo_upgradepkg()\fR runs \f(CW\*(C`upgradepkg \-\-reinstall \-\-install\-new\*(C'\fR on \f(CW$pkg\fR.
.PP
There is no useful return value.
.SS get_build_queue
.IX Subsection "get_build_queue"
.Vb 1
\&  my @queue = @{ get_build_queue($sbo, my $warnings, my @checked) };
.Ve
.PP
\&\f(CWget_build_queue()\fR gets the prerequisites for \f(CW$sbo\fR, updating the
\&\f(CW$warnings\fR hash reference with any \f(CW\*(C`%README%\*(C'\fR encountered. It returns the
prerequisites and \f(CW$sbo\fR in the correct build order.
.PP
\&\f(CW@checked\fR and \f(CW\*(C`our @concluded\*(C'\fR are used to check for circular dependencies; the
script exits with \f(CW\*(C`_ERR_CIRCULAR\*(C'\fR if any are present.
.SS get_dc_regex
.IX Subsection "get_dc_regex"
.Vb 1
\&  my ($rx, $initial) = get_dc_regex($line);
.Ve
.PP
\&\f(CWget_dc_regex()\fR creates a regular expression that should match the filename
given a line with e.g. an untar command. This is returned together with the \f(CW$initial\fR
character, which starts the filename match.
.SS get_full_queue
.IX Subsection "get_full_queue"
.Vb 1
\&  my @revdep_queue = ($installed, @sbos);
.Ve
.PP
\&\f(CWget_full_queue()\fR takes a list of installed SlackBuilds and an array
of SlackBuilds to check. It returns a list of the checked SlackBuilds and
their dependencies in reverse build order.
.SS get_full_reverse
.IX Subsection "get_full_reverse"
.Vb 1
\&  my @get_full_reverse = get_full_reverse($sbo, %installed, %fulldeps, my @checked, my @list)
.Ve
.PP
\&\f(CWget_full_reverse()\fR takes a SlackBuild, a hash of installed packages, a hash
of reverse dependency relationships (from \f(CW\*(C`get_reverse_reqs\*(C'\fR) and two arrays.
These arrays should not be included when called from outside of the subroutine.
\&\f(CWget_full_reverse()\fR returns an array with installed reverse dependencies.
.PP
The final level of reverse dependencies is kept in the shared array \f(CW@last_level_reverse\fR;
these are displayed only by \f(CW\*(C`sbofind \-\-top\-reverse\*(C'\fR.
.PP
If any circular reverse dependencies are found, the script exits with \f(CW\*(C`_ERR_CIRCULAR\*(C'\fR.
.SS get_full_reverse_queue
.IX Subsection "get_full_reverse_queue"
.Vb 2
\&  my (@reverse_queue, %warnings) = get_full_reverse_queue($from, $updates, $sbo ...)
\&  my (@reverse_queue, %warnings) = get_full_reverse_queue($from, $self_include, $sbo ...)
.Ve
.PP
\&\f(CWget_full_reverse_queue()\fR takes the name of the script it is called from and any number
of SlackBuilds. The second variable is the list of available upgrades (if called from
\&\fBsboupgrade\|(1)\fR), any true value if called from \fBsboinstall\|(1) \-\-reinstall\fR and a
false value otherwise. The subroutine returns a queue for a reverse dependency rebuild
and a warnings hash.
.SS get_pkg_name
.IX Subsection "get_pkg_name"
.Vb 1
\&  my $name = get_pkg_name($str);
.Ve
.PP
\&\f(CWget_pkg_name()\fR searches \f(CW$str\fR for text matching the package name output
from \f(CW\*(C`makepkg\*(C'\fR. The package name is returned.
.SS get_src_dir
.IX Subsection "get_src_dir"
.Vb 1
\&  my @dirs = @{ get_src_dir(@orig_dirs) };
.Ve
.PP
\&\f(CWget_src_dir()\fR returns a list of those directories under \f(CW\*(C`/tmp/SBo\*(C'\fR or \f(CW$TMP\fR
that are not in \f(CW@orig_dirs\fR. That is, the source directories for the script.
.SS get_tmp_extfn
.IX Subsection "get_tmp_extfn"
.Vb 1
\&  my ($ret, $exit) = get_tmp_extfn($fh);
.Ve
.PP
\&\f(CWget_tmp_extfn()\fR gets the \f(CW\*(C`/dev/fd/X\*(C'\fR filename for the file handle \f(CW$fh\fR passed
in, setting flats to make it usable from other processes.
.PP
It returns the filename if successful, and \f(CW\*(C`undef\*(C'\fR otherwise.
.SS make_clean
.IX Subsection "make_clean"
.Vb 1
\&  make_clean(SBO => $sbo, SRC => $src, VERSION => $ver);
.Ve
.PP
\&\f(CWmake_clean()\fR removes source, package and compat32 directories left after running
a SlackBuild.
.PP
It has no useful return value.
.SS make_distclean
.IX Subsection "make_distclean"
.Vb 1
\&  make_distclean(SRC => $src, VERSION => $ver, LOCATION => $loc);
.Ve
.PP
\&\f(CWmake_distclean()\fR removes any downloaded source tarballs and the completed package
archive. These files are not removed if they are needed by a script later in the
queue; this is mostly relevant for compat32 and some Rust-based scripts.
.PP
It has no useful return value.
.SS merge_queues
.IX Subsection "merge_queues"
.Vb 1
\&  my @merged = @{ merge_queues([@queue1], [@queue2]) };
.Ve
.PP
\&\f(CWmerge_queues()\fR takes two array references and merges them such that \f(CW@queue1\fR
is in front, followed by any non-redundant items in \f(CW@queue2\fR. This is returned
as an array reference.
.SS perform_sbo
.IX Subsection "perform_sbo"
.Vb 1
\&  my ($pkg, $src, $exit) = perform_sbo(LOCATION => $location, ARCH => $arch);
.Ve
.PP
\&\f(CWperform_sbo()\fR prepares and runs a SlackBuild. It returns the package name,
an array with source directories and an exit code if successful. If unsuccessful,
the first value is instead an error message.
.SS process_sbos
.IX Subsection "process_sbos"
.Vb 1
\&  my (@failures, $exit) = process_sbos(TODO => [@queue]);
.Ve
.PP
\&\f(CWprocess_sbos()\fR processes a \f(CW@queue\fR of SlackBuilds and returns an array reference
with failed builds and the exit status.
.PP
In case of a mass rebuild, \f(CW\*(C`process_sbos\*(C'\fR updates the resume file \f(CW\*(C`resume.temp\*(C'\fR
when a build fails.
.SS rationalize_queue
.IX Subsection "rationalize_queue"
.Vb 1
\&  my $queue = rationalize_queue($queue)
.Ve
.PP
\&\f(CWrationalize_queue()\fR takes a build queue and rearranges it such that
no script appears before any of its dependencies. Currently, this is only
useful when an automatic reverse dependency rebuild has been triggered or
in case of a mass rebuild. The rearranged queue is returned.
.SS revert_slackbuild
.IX Subsection "revert_slackbuild"
.Vb 1
\&  revert_slackbuild($path);
.Ve
.PP
\&\f(CWrevert_slackbuild()\fR restores a SlackBuild rewritten by
\&\f(CWrewrite_slackbuild()\fR.
.PP
There is no useful return value.
.SS rewrite_slackbuild
.IX Subsection "rewrite_slackbuild"
.Vb 1
\&  my ($ret, $exit) = rewrite_slackbuild(%args);
.Ve
.PP
\&\f(CWrewrite_slackbuild()\fR, when given an argument hash, copies the SlackBuild
at \f(CW$path\fR and rewrites it with the needed changes. The required arguments include
\&\f(CW\*(C`SBO\*(C'\fR (the name of the script), \f(CW\*(C`SLACKBUILD\*(C'\fR (the location of the unaltered
SlackBuild), \f(CW\*(C`CHANGES\*(C'\fR (the required changes) and \f(CW\*(C`C32\*(C'\fR (0 if the build is not
compat32, and 1 if it is).
.PP
On failure, an error message and the exit status are returned. On success, 1 and an exit
status of 0 are returned.
.SS run_tee
.IX Subsection "run_tee"
.Vb 1
\&  my ($output, $exit) = run_tee($cmd);
.Ve
.PP
\&\f(CWrun_tee()\fR runs \f(CW$cmd\fR under \f(CWtee(1)\fR to display STDOUT and return it as
a string. The second return value is the exit status.
.PP
If the bash interpreter cannot be run, the first return value is \f(CW\*(C`undef\*(C'\fR and
the exit status holds a non-zero value.
.SH "EXIT CODES"
.IX Header "EXIT CODES"
Build.pm subroutines can return the following exit codes:
.PP
.Vb 8
\&  _ERR_SCRIPT        2   script or module bug
\&  _ERR_BUILD         3   errors when executing a SlackBuild
\&  _ERR_OPENFH        6   failure to open file handles
\&  _ERR_NOMULTILIB    9   lacking multilib capabilities when needed
\&  _ERR_CONVERTPKG    10  convertpkg\-compat32 failure
\&  _ERR_NOCONVERTPKG  11  lacking convertpkg\-compat32 when needed
\&  _ERR_INST_SIGNAL   12  the script was interrupted while building
\&  _ERR_CIRCULAR      13  attempted to calculate a circular dependency
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fBSBO::Lib\fR\|(3), \fBSBO::Lib::Download\fR\|(3), \fBSBO::Lib::Info\fR\|(3), \fBSBO::Lib::Pkgs\fR\|(3), \fBSBO::Lib::Readme\fR\|(3), \fBSBO::Lib::Repo\fR\|(3), \fBSBO::Lib::Tree\fR\|(3), \fBSBO::Lib::Util\fR\|(3)
.SH AUTHORS
.IX Header "AUTHORS"
SBO::Lib was originally written by Jacob Pipkin <j@dawnrazor.net> with
contributions from Luke Williams <xocel@iquidus.org> and Andreas
Guldstrand <andreas.guldstrand@gmail.com>.
.SH MAINTAINER
.IX Header "MAINTAINER"
SBO::Lib is maintained by K. Eugene Carlson <kvngncrlsn@gmail.com>.
.SH LICENSE
.IX Header "LICENSE"
The sbotools are licensed under the MIT License.
.PP
Copyright (C) 2012\-2017, Jacob Pipkin, Luke Williams, Andreas Guldstrand.
.PP
Copyright (C) 2024\-2025, K. Eugene Carlson.
