.\" -*- mode: troff; coding: utf-8 -*-
.\" Automatically generated by Pod::Man 5.0102 (Pod::Simple 3.45)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" \*(C` and \*(C' are quotes in nroff, nothing in troff, for use with C<>.
.ie n \{\
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "SBO::Lib::Util 3"
.TH SBO::Lib::Util 3 "Pungenday, The Aftermath 61, 3190 YOLD" "" "sbotools 3.1"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH NAME
SBO::Lib::Util \- Utility functions for SBO::Lib and the sbotools
.SH SYNOPSIS
.IX Header "SYNOPSIS"
.Vb 1
\&  use SBO::Lib::Util qw/uniq/;
\&
\&  # (\*(Aqduplicate\*(Aq);
\&  my @uniq = uniq(\*(Aqduplicate\*(Aq, \*(Aqduplicate\*(Aq);
.Ve
.SH VARIABLES
.IX Header "VARIABLES"
.ie n .SS $conf_dir
.el .SS \f(CW$conf_dir\fP
.IX Subsection "$conf_dir"
\&\f(CW$conf_dir\fR is \f(CW\*(C`/etc/sbotools\*(C'\fR.
.ie n .SS $conf_file
.el .SS \f(CW$conf_file\fP
.IX Subsection "$conf_file"
\&\f(CW$conf_file\fR is \f(CW\*(C`/etc/sbotools/sbotools.conf\*(C'\fR.
.ie n .SS %config
.el .SS \f(CW%config\fP
.IX Subsection "%config"
All values default to \f(CW"FALSE"\fR, but when \f(CWread_config()\fR is run,
they change according to the configuration. \f(CW\*(C`SBO_HOME\*(C'\fR is changed to
\&\f(CW\*(C`/usr/sbo\*(C'\fR if still \f(CW"FALSE"\fR.
.PP
The supported keys are: \f(CW\*(C`NOCLEAN\*(C'\fR, \f(CW\*(C`DISTCLEAN\*(C'\fR, \f(CW\*(C`JOBS\*(C'\fR, \f(CW\*(C`PKG_DIR\*(C'\fR,
\&\f(CW\*(C`SBO_HOME\*(C'\fR, \f(CW\*(C`LOCAL_OVERRIDES\*(C'\fR, \f(CW\*(C`SLACKWARE_VERSION\*(C'\fR, \f(CW\*(C`REPO\*(C'\fR, \f(CW\*(C`BUILD_IGNORE\*(C'\fR,
\&\f(CW\*(C`GPG_VERIFY\*(C'\fR and \f(CW\*(C`RSYNC_DEFAULT\*(C'\fR.
.ie n .SS @listings
.el .SS \f(CW@listings\fP
.IX Subsection "@listings"
An array with blacklisted packages and optional dependency requests read in
from \f(CW\*(C`/etc/sbotools/sbotools.hints\*(C'\fR. Non-exportable.
.SH SUBROUTINES
.IX Header "SUBROUTINES"
.SS build_cmp
.IX Subsection "build_cmp"
.Vb 1
\&  my $cmp = build_cmp($build1, $build2, $ver1, $ver2);
.Ve
.PP
\&\f(CWbuild_cmp()\fR compares \f(CW$build1\fR with \f(CW$build2\fR while checking that \f(CW$ver1\fR
and \f(CW$ver2\fR are different. If the build numbers are not the same and the version
numbers are, upgrading for a script bump may be in order.
.SS check_multilib
.IX Subsection "check_multilib"
.Vb 1
\&  my $ml = check_multilib();
.Ve
.PP
\&\f(CWcheck_multilib()\fR for \f(CW\*(C`/etc/profile.d/32dev.sh\*(C'\fR existence.
The sbotools use this file to build 32\-bit packages on x64 architecture.
.PP
Returns 1 if so, and 0 otherwise.
.SS get_arch
.IX Subsection "get_arch"
.Vb 1
\&  my $arch = get_arch();
.Ve
.PP
\&\f(CWget_arch()\fR returns the machine architechture as reported by \f(CW\*(C`uname
\&\-m\*(C'\fR.
.SS get_kernel_version
.IX Subsection "get_kernel_version"
.Vb 1
\&  my $kv = get_kernel_version();
.Ve
.PP
\&\f(CWget_kernel_version()\fR checks the version of the running kernel, and returns
it in a format suitable for appending to a Slackware package version.
.SS get_optional
.IX Subsection "get_optional"
.Vb 1
\&  my $optional = get_optional($sbo)
.Ve
.PP
\&\f(CWget_optional()\fR checks for user-requested optional dependencies for \f(CW$sbo\fR. Note that
global array \f(CW@listings\fR is copied.
.SS get_sbo_from_loc
.IX Subsection "get_sbo_from_loc"
.Vb 1
\&  my $sbo = get_sbo_from_loc($location);
.Ve
.PP
\&\f(CWget_sbo_from_loc()\fR returns the package name from the \f(CW$location\fR passed in.
.SS get_slack_version
.IX Subsection "get_slack_version"
.Vb 1
\&  my $version = get_slack_version();
.Ve
.PP
\&\f(CWget_slack_version()\fR returns the appropriate version of the SBo reposiotry.
.PP
The program exits if the version is unsupported or if an error occurs.
.SS get_slack_version_url
.IX Subsection "get_slack_version_url"
.Vb 1
\&  my $url = get_slack_version_url();
.Ve
.PP
\&\f(CWget_slack_version_url()\fR returns the default URL for the given Slackware
version.
.PP
The program exits if the version is unsupported or if an error occurs.
.SS get_slack_branch
.IX Subsection "get_slack_branch"
.Vb 1
\&  my $url = get_slack_branch();
.Ve
.PP
\&\f(CWget_slack_branch()\fR returns the default git branch for the given Slackware
version, if any. If the pulled repository does not have this branch, an onscreen
message will appear.
.SS idx
.IX Subsection "idx"
.Vb 1
\&  my $idx = idx($needle, @haystack);
.Ve
.PP
\&\f(CWidx()\fR looks for \f(CW$needle\fR in \f(CW@haystack\fR, and returns the index of where
it was found, or \f(CW\*(C`undef\*(C'\fR if it was not found.
.SS in
.IX Subsection "in"
.Vb 1
\&  my $found = in($needle, @haystack);
.Ve
.PP
\&\f(CWin()\fR looks for \f(CW$needle\fR in \f(CW@haystack\fR, and returns a true value if it
was found, and a false value otherwise.
.SS indent
.IX Subsection "indent"
.Vb 1
\&  my $str = indent($indent, $text);
.Ve
.PP
\&\f(CWindent()\fR indents every non-empty line in \f(CW$text\fR by \f(CW$indent\fR spaces and
returns the resulting string.
.SS lint_sbo_home
.IX Subsection "lint_sbo_home"
.Vb 1
\&  lint_sbo_home();
.Ve
.PP
\&\f(CWlint_sbo_home()\fR runs at the start of every script except for \f(CW\*(C`sboconfig\*(C'\fR;
it exits if \f(CW\*(C`SBO_HOME\*(C'\fR is not an absolute directory path (or FALSE, which defaults to
/usr/sbo).
.SS on_blacklist
.IX Subsection "on_blacklist"
.Vb 1
\&  my $result = on_blacklist($sbo);
.Ve
.PP
\&\f(CWon_blacklist()\fR checks whether \f(CW$sbo\fR has been blacklisted. Note that
global array \f(CW@listings\fR is copied.
.SS open_fh
.IX Subsection "open_fh"
.Vb 1
\&  my ($ret, $exit) = open_fh($fn, $op);
.Ve
.PP
\&\f(CWopen_fh()\fR will open \f(CW$fn\fR for reading and/or writing depending on
\&\f(CW$op\fR.
.PP
It returns two values: the file handle and the exit status. If the exit status
is non-zero, it will return an error message rather than a file handle.
.SS open_read
.IX Subsection "open_read"
.Vb 1
\&  my ($ret, $exit) = open_read($fn);
.Ve
.PP
\&\f(CWopen_read()\fR opens \f(CW$fn\fR for reading.
.PP
It returns two values: the file handle and the exit status. If the exit status
is non-zero, it will return an error message rather than a file handle.
.SS print_failures
.IX Subsection "print_failures"
.Vb 1
\&  print_failures($failures);
.Ve
.PP
\&\f(CWprint_failures()\fR prints all failures in the \f(CW$failures\fR array reference
to STDERR, if any.
.PP
There is no useful return value.
.SS prompt
.IX Subsection "prompt"
.Vb 1
\&  exit unless prompt "Should we continue?", default => "yes";
.Ve
.PP
\&\f(CWprompt()\fR prompts the user for an answer, optionally specifying a default of
\&\f(CW\*(C`yes\*(C'\fR or \f(CW\*(C`no\*(C'\fR.
.PP
If the default has been specified, it returns a true value for 'yes' and a false
one for 'no'. Otherwise, it returns the content of the user's answer.
.SS read_config
.IX Subsection "read_config"
.Vb 1
\&  read_config();
.Ve
.PP
\&\f(CWread_config()\fR reads in the configuration settings from
\&\f(CW\*(C`/etc/sbotools/sbotools.conf\*(C'\fR, updating the \f(CW%config\fR hash. If
\&\f(CW\*(C`SBO_HOME\*(C'\fR is \f(CW\*(C`FALSE\*(C'\fR, it changes to \f(CW\*(C`/usr/sbo\*(C'\fR.
Additionally, \f(CW\*(C`BUILD_IGNORE\*(C'\fR and \f(CW\*(C`RSYNC_DEFAULT\*(C'\fR are turned on if
\&\f(CW\*(C`CLASSIC\*(C'\fR is \f(CW\*(C`TRUE\*(C'\fR.
.PP
There is no useful return value.
.SS read_hints
.IX Subsection "read_hints"
.Vb 1
\&  our @listings = read_hints()
.Ve
.PP
\&\f(CWread_hints()\fR reads the contents of /etc/sbotools/sbotools.hints, returning an array
of optional dependency requests and blacklisted scripts. \f(CWread_hints()\fR is used to
populate global array \f(CW@listings\fR, and should only be called once.
.SS save_options
.IX Subsection "save_options"
.Vb 1
\&  save_options($sbo, $opts)
.Ve
.PP
\&\f(CWsave_options()\fR saves build options to \f(CW\*(C`/var/log/sbotools/sbo\*(C'\fR. If the file
already exists and the user supplies no build options, the existing file is
retained.
.SS script_error
.IX Subsection "script_error"
.Vb 2
\&  script_error();
\&  script_error($msg);
.Ve
.PP
\&\fBscript_error()\fR warns and exits, printing the following to STDERR:
.PP
.Vb 1
\&  A fatal script error has occurred. Exiting.
.Ve
.PP
If a \f(CW$msg\fR was supplied, it instead prints:
.PP
.Vb 3
\&  A fatal script error has occurred:
\&  $msg.
\&  Exiting.
.Ve
.PP
There is no useful return value.
.SS show_version
.IX Subsection "show_version"
.Vb 1
\&  show_version();
.Ve
.PP
\&\f(CWshow_version()\fR prints the sbotools version and licensing information
to STDOUT.
.PP
There is no useful return value.
.SS slurp
.IX Subsection "slurp"
.Vb 1
\&  my $data = slurp($fn);
.Ve
.PP
\&\f(CWslurp()\fR takes a filename in \f(CW$fn\fR, opens it, and reads in the entire file.
The contents are then returned. On error, it returns \f(CW\*(C`undef\*(C'\fR.
.SS uniq
.IX Subsection "uniq"
.Vb 1
\&  my @uniq = uniq(@duplicates);
.Ve
.PP
\&\f(CWuniq()\fR removes any duplicates from \f(CW@duplicates\fR, otherwise returning the
list in the same order.
.SS usage_error
.IX Subsection "usage_error"
.Vb 1
\&  usage_error($msg);
.Ve
.PP
\&\f(CWusage_error()\fR warns and exits, printing \f(CW$msg\fR to STDERR.
.PP
There is no useful return value.
.SS version_cmp
.IX Subsection "version_cmp"
.Vb 1
\&  my $cmp = version_cmp($ver1, $ver2);
.Ve
.PP
\&\f(CWversion_cmp()\fR compares \f(CW$ver1\fR with \f(CW$ver2\fR. It returns 1 if \f(CW$ver1\fR is higher,
\&\-1 if \f(CW$ver2\fR is higher and 0 if they are equal. It strips the running kernel version,
as well as any locale information that may have been appended to the version strings.
.SH AUTHORS
.IX Header "AUTHORS"
SBO::Lib was originally written by Jacob Pipkin <j@dawnrazor.net> with
contributions from Luke Williams <xocel@iquidus.org> and Andreas
Guldstrand <andreas.guldstrand@gmail.com>.
.PP
SBO::Lib is maintained by K. Eugene Carlson <kvngncrlsn@gmail.com>.
.SH LICENSE
.IX Header "LICENSE"
The sbotools are licensed under the MIT License.
.PP
Copyright (C) 2012\-2017, Jacob Pipkin, Luke Williams, Andreas Guldstrand.
.PP
Copyright (C) 2024, K. Eugene Carlson.
