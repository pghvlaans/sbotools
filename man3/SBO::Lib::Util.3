.\" -*- mode: troff; coding: utf-8 -*-
.\" Automatically generated by Pod::Man v6.0.2 (Pod::Simple 3.45)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" \*(C` and \*(C' are quotes in nroff, nothing in troff, for use with C<>.
.ie n \{\
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Required to disable full justification in groff 1.23.0.
.if n .ds AD l
.\" ========================================================================
.\"
.IX Title "SBO::Lib::Util 3"
.TH SBO::Lib::Util 3 "Setting Orange, Confusion 54, 3191 YOLD" "" "sbotools 3.7"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH NAME
SBO::Lib::Util \- Utility functions for SBO::Lib and the sbotools
.SH SYNOPSIS
.IX Header "SYNOPSIS"
.Vb 1
\&  use SBO::Lib::Util qw/uniq/;
\&
\&  # (\*(Aqduplicate\*(Aq);
\&  my @uniq = uniq(\*(Aqduplicate\*(Aq, \*(Aqduplicate\*(Aq);
.Ve
.SH VARIABLES
.IX Header "VARIABLES"
.ie n .SS "($color_default, $color_lesser, $color_notice, $color_warn)"
.el .SS "($color_default, \f(CW$color_lesser\fP, \f(CW$color_notice\fP, \f(CW$color_warn\fP)"
.IX Subsection "($color_default, $color_lesser, $color_notice, $color_warn)"
These variables are ANSI colors. \f(CW$color_notice\fR is \f(CW\*(C`cyan\*(C'\fR for selected
\&\f(CW\*(C`sbotools\*(C'\fR informative messages. \f(CW$color_lesser\fR is \f(CW\*(C`bold\*(C'\fR for warnings
of lesser concern. \f(CW$color_warn\fR, \f(CW\*(C`red bold\*(C'\fR, is for errors and warnings of greater concern.
\&\f(CW\*(C`sbotools\*(C'\fR color display can be disabled by setting \f(CW\*(C`NOCOLOR\*(C'\fR to \f(CW\*(C`TRUE\*(C'\fR. \f(CW$color_default\fR
is currently \f(CW\*(C`reset\*(C'\fR and is not configurable.
.PP
\&\f(CWget_colors()\fR reads \f(CW\*(C`/etc/sbotools/sbotools.colors\*(C'\fR for custom values.
.ie n .SS $conf_dir
.el .SS \f(CW$conf_dir\fP
.IX Subsection "$conf_dir"
\&\f(CW$conf_dir\fR is \f(CW\*(C`/etc/sbotools\*(C'\fR by default, or else the contents of an
environment variable \f(CW\*(C`SBOTOOLS_CONF_DIR\*(C'\fR.
.ie n .SS $conf_file
.el .SS \f(CW$conf_file\fP
.IX Subsection "$conf_file"
\&\f(CW$conf_file\fR is \f(CW\*(C`/etc/sbotools/sbotools.conf\*(C'\fR by default.
.ie n .SS %config
.el .SS \f(CW%config\fP
.IX Subsection "%config"
All values default to \f(CW"FALSE"\fR, but when \f(CWread_config()\fR is run,
they change according to the configuration. \f(CW\*(C`SBO_HOME\*(C'\fR is changed to
\&\f(CW\*(C`/usr/sbo\*(C'\fR if still \f(CW"FALSE"\fR.
.PP
The supported keys are: \f(CW\*(C`NOCLEAN\*(C'\fR, \f(CW\*(C`DISTCLEAN\*(C'\fR, \f(CW\*(C`JOBS\*(C'\fR, \f(CW\*(C`PKG_DIR\*(C'\fR,
\&\f(CW\*(C`SBO_HOME\*(C'\fR, \f(CW\*(C`LOCAL_OVERRIDES\*(C'\fR, \f(CW\*(C`SLACKWARE_VERSION\*(C'\fR, \f(CW\*(C`REPO\*(C'\fR, \f(CW\*(C`BUILD_IGNORE\*(C'\fR,
\&\f(CW\*(C`GPG_VERIFY\*(C'\fR, \f(CW\*(C`RSYNC_DEFAULT\*(C'\fR, \f(CW\*(C`STRICT_UPGRADES\*(C'\fR, \f(CW\*(C`GIT_BRANCH\*(C'\fR, \f(CW\*(C`CLASSIC\*(C'\fR,
\&\f(CW\*(C`CPAN_IGNORE\*(C'\fR, \f(CW\*(C`ETC_PROFILE\*(C'\fR, \f(CW\*(C`LOG_DIR\*(C'\fR, \f(CW\*(C`NOWRAP\*(C'\fR and \f(CW\*(C`NOCOLOR\*(C'\fR.
.ie n .SS $download_time
.el .SS \f(CW$download_time\fP
.IX Subsection "$download_time"
The time spent downloading source files. Unless \f(CW\*(C`CLASSIC\*(C'\fR is \f(CW"TRUE"\fR, it is
displayed when all builds are complete.
.ie n .SS $head_file
.el .SS \f(CW$head_file\fP
.IX Subsection "$head_file"
A file, \f(CW\*(C`/etc/sbotools/sbotools.hints\*(C'\fR by default, containing blacklisted scripts,
optional script dependencies and automatic revese dependency rebuild requests.
.ie n .SS $is_sbotest
.el .SS \f(CW$is_sbotest\fP
.IX Subsection "$is_sbotest"
This shared variable indicates a run from \f(CW\*(C`sbotest\*(C'\fR.
.ie n .SS $sbotest_compatible
.el .SS \f(CW$sbotest_compatible\fP
.IX Subsection "$sbotest_compatible"
This shared variable indicates compatibility with the \f(CW\*(C`sbotest\*(C'\fR companion package.
.ie n .SS $total_build_time
.el .SS \f(CW$total_build_time\fP
.IX Subsection "$total_build_time"
A running total of the time it took to build and package each script in the queue.
Unless \f(CW\*(C`CLASSIC\*(C'\fR is \f(CW"TRUE"\fR, it is displayed when all builds are complete.
.ie n .SS $total_install_time
.el .SS \f(CW$total_install_time\fP
.IX Subsection "$total_install_time"
A running total of the time it took to install each script in the queue. Unless
\&\f(CW\*(C`CLASSIC\*(C'\fR is \f(CW"TRUE"\fR, it is displayed when all builds are complete.
.ie n .SS "($paused_time, $resume_time, $stop_time)"
.el .SS "($paused_time, \f(CW$resume_time\fP, \f(CW$stop_time\fP)"
.IX Subsection "($paused_time, $resume_time, $stop_time)"
These variables are used to track any time spent stopped by keyboard interrupt.
Times are adjusted in the \f(CWreconcile_time()\fR subroutine before reporting.
.ie n .SS @listings
.el .SS \f(CW@listings\fP
.IX Subsection "@listings"
An array with blacklisted scripts and requests for optional dependencies and
automatic reverse dependency rebuilds read in from \f(CW\*(C`/etc/sbotools/sbotools.hints\*(C'\fR.
Only \f(CWread_hints()\fR should interact with \f(CW@listings\fR directly; in other
situations, make a copy (see e.g. \f(CW@on_blacklist()\fR.)
.ie n .SS $obs_file
.el .SS \f(CW$obs_file\fP
.IX Subsection "$obs_file"
This file contains a list of scripts that have been renamed and added to Slackware
\&\-current, or are known to be obsolete build dependencies. It is located at
\&\f(CW\*(C`/etc/sbotools/obsolete\*(C'\fR by default.
.ie n .SS @obsolete
.el .SS \f(CW@obsolete\fP
.IX Subsection "@obsolete"
This array is based on the contents of \f(CW$obs_file\fR. Only \f(CWobsolete_array()\fR should
interact with \f(CW@obsolete\fR directly; in other situations, make a copy.
.ie n .SS $userland_32
.el .SS \f(CW$userland_32\fP
.IX Subsection "$userland_32"
\&\f(CWget_arch()\fR defines this variable when running in a 32\-bit userland on a 64\-bit
kernel.
.SH SUBROUTINES
.IX Header "SUBROUTINES"
.SS auto_reverse
.IX Subsection "auto_reverse"
.Vb 1
\&  my $result = auto_reverse($sbo)
.Ve
.PP
\&\f(CWauto_reverse()\fR checks whether automatic reverse dependency rebuilding for \f(CW$sbo\fR has
been requested. Results will be the same for the \f(CW\*(C`compat32\*(C'\fR version of the script. Note
that global array \f(CW@listings\fR is copied.
.SS build_cmp
.IX Subsection "build_cmp"
.Vb 1
\&  my $cmp = build_cmp($build1, $build2, $ver1, $ver2);
.Ve
.PP
\&\f(CWbuild_cmp()\fR compares \f(CW$build1\fR with \f(CW$build2\fR while checking that \f(CW$ver1\fR
and \f(CW$ver2\fR are different. If the build numbers are not the same and the version
numbers are, upgrading for a script bump may be in order.
.SS check_multilib
.IX Subsection "check_multilib"
.Vb 1
\&  my $ml = check_multilib();
.Ve
.PP
\&\f(CWcheck_multilib()\fR verifies \f(CW\*(C`/etc/profile.d/32dev.sh\*(C'\fR existence.
The sbotools use this file to build 32\-bit packages on x64 architecture.
.PP
Returns 1 if the file exists, and 0 otherwise.
.SS dangerous_directory
.IX Subsection "dangerous_directory"
.Vb 1
\&  my $dangerous = dangerous_directory($dirname);
.Ve
.PP
\&\f(CWdangerous_directory()\fR takes a string and returns true if it is equal to \f(CW\*(C`/\*(C'\fR,
\&\f(CW\*(C`/root\*(C'\fR, \f(CW\*(C`/home\*(C'\fR or a possible directory under \f(CW\*(C`/home\*(C'\fR.
.SS error_code
.IX Subsection "error_code"
.Vb 1
\&  error_code($message, $code);
.Ve
.PP
\&\f(CWerror_code()\fR takes a message and an error code. The message is displayed
wrapped at 72 characters and the script exits with the specified error code.
There is no useful return value.
.PP
For _ERR_USAGE and _ERR_SCRIPT, use \f(CWusage_error()\fR and \f(CWscript_error()\fR,
respectively.
.SS display_times
.IX Subsection "display_times"
.Vb 1
\&  display_times();
.Ve
.PP
\&\f(CWdisplay_times()\fR shows the time spent downloading, packaging and installing
the scripts in the build queue. It takes no arguments and has no useful return
value.
.SS get_arch
.IX Subsection "get_arch"
.Vb 1
\&  my $arch = get_arch();
.Ve
.PP
\&\f(CWget_arch()\fR returns the machine architechture as reported by \f(CW\*(C`uname
\&\-m\*(C'\fR. For the \f(CW\*(C`x86_64\*(C'\fR architecture, additionally check whether \f(CW\*(C`/bin/bash\*(C'\fR
is 64\- or 32\-bit to account for 32\-bit userlands running on a 64\-bit kernel.
.SS get_colors
.IX Subsection "get_colors"
.Vb 1
\&  my ($color_notice, $color_lesser, $color_warn) = get_colors();
.Ve
.PP
\&\f(CWget_colors()\fR reads the contents of \f(CW\*(C`/etc/sbotools/sbotools.colors\*(C'\fR to
set custom values for \f(CW$color_notice\fR, \f(CW$color_lesser\fR and \f(CW$color_warn\fR.
No color can be set to an invalid ANSI specification; in such cases, the default
value is used instead. See \f(CWTerm::ANSIColor(3)\fR for details.
.SS get_kernel_version
.IX Subsection "get_kernel_version"
.Vb 1
\&  my $kv = get_kernel_version();
.Ve
.PP
\&\f(CWget_kernel_version()\fR checks the version of the running kernel and returns
it in a format suitable for appending to a Slackware package version.
.SS get_optional
.IX Subsection "get_optional"
.Vb 1
\&  my $optional = get_optional($sbo)
.Ve
.PP
\&\f(CWget_optional()\fR checks for user\-requested optional dependencies for \f(CW$sbo\fR.
In all cases, results for \f(CW\*(C`compat32\*(C'\fR scripts have the corresponding \f(CW\*(C`compat32\*(C'\fR
scripts to the results for the base script. Note that global array \f(CW@listings\fR is
copied.
.SS get_sbo_from_loc
.IX Subsection "get_sbo_from_loc"
.Vb 1
\&  my $sbo = get_sbo_from_loc($location);
.Ve
.PP
\&\f(CWget_sbo_from_loc()\fR returns the package name from the \f(CW$location\fR passed in.
.SS get_slack_version
.IX Subsection "get_slack_version"
.Vb 1
\&  my $version = get_slack_version();
.Ve
.PP
\&\f(CWget_slack_version()\fR returns the appropriate version of the SBo reposiotry.
.PP
The program exits if the version is unsupported or if an error occurs.
.SS get_slack_version_url
.IX Subsection "get_slack_version_url"
.Vb 1
\&  my $url = get_slack_version_url();
.Ve
.PP
\&\f(CWget_slack_version_url()\fR returns the default URL for the given Slackware
version.
.PP
The program exits if the version is unsupported or if an error occurs.
.SS get_slack_branch
.IX Subsection "get_slack_branch"
.Vb 1
\&  my $url = get_slack_branch();
.Ve
.PP
\&\f(CWget_slack_branch()\fR returns the default git branch for the given Slackware
version, if any. If the upstream repository does not have this branch, an onscreen
message appears.
.SS idx
.IX Subsection "idx"
.Vb 1
\&  my $idx = idx($needle, @haystack);
.Ve
.PP
\&\f(CWidx()\fR looks for \f(CW$needle\fR in \f(CW@haystack\fR, and returns the index of where
it was found, or \f(CW\*(C`undef\*(C'\fR if it was not found.
.SS in
.IX Subsection "in"
.Vb 1
\&  my $found = in($needle, @haystack);
.Ve
.PP
\&\f(CWin()\fR looks for \f(CW$needle\fR in \f(CW@haystack\fR, and returns a true value if it
was found, and a false value otherwise.
.SS indent
.IX Subsection "indent"
.Vb 1
\&  my $str = indent($indent, $text);
.Ve
.PP
\&\f(CWindent()\fR indents every non\-empty line in \f(CW$text\fR by \f(CW$indent\fR spaces and
returns the resulting string.
.SS is_obsolete
.IX Subsection "is_obsolete"
.Vb 1
\&  my $is_obsolete = check_obsolete($sbo);
.Ve
.PP
\&\f(CWis_obsolete()\fR takes the name of a SlackBuild and searches for it in
the \f(CW@obsolete\fR array. It returns 1 if the SlackBuild is found and the
Slackware version is \-current equivalent.
.SS lint_sbo_config
.IX Subsection "lint_sbo_config"
.Vb 1
\&  lint_sbo_config($running_script, %configs);
.Ve
.PP
\&\f(CWlint_sbo_config()\fR takes the name of an sbotools script and a hash with configuration
parameters. It checks the validity of all parameters except for REPO,
exiting with an error message in case of invalid options.
.PP
\&\f(CWsboconfig(1)\fR runs this subroutine to lint any requested parameter changes;
all other scripts lint the full configuration at startup.
.SS obsolete_array
.IX Subsection "obsolete_array"
.Vb 1
\&  our @obsolete = obsolete_array();
.Ve
.PP
\&\f(CWobsolete_array()\fR populates the shared \f(CW@obsolete\fR array based on the
\&\f(CW\*(C`/etc/sbotools/obsolete\*(C'\fR file.
.SS on_blacklist
.IX Subsection "on_blacklist"
.Vb 1
\&  my $result = on_blacklist($sbo);
.Ve
.PP
\&\f(CWon_blacklist()\fR checks whether \f(CW$sbo\fR has been blacklisted. Results will
be the same for the \f(CW\*(C`compat32\*(C'\fR version of the script. Note that global array
\&\f(CW@listings\fR is copied.
.SS open_fh
.IX Subsection "open_fh"
.Vb 1
\&  my ($ret, $exit) = open_fh($fn, $op);
.Ve
.PP
\&\f(CWopen_fh()\fR opens \f(CW$fn\fR for reading and/or writing depending on
\&\f(CW$op\fR.
.PP
It returns two values: the file handle and the exit status. If the exit status
is non\-zero, it returns an error message rather than a file handle.
.SS open_read
.IX Subsection "open_read"
.Vb 1
\&  my ($ret, $exit) = open_read($fn);
.Ve
.PP
\&\f(CWopen_read()\fR opens \f(CW$fn\fR for reading.
.PP
It returns two values: the file handle and the exit status. If the exit status
is non\-zero, it returns an error message rather than a file handle.
.SS print_color
.IX Subsection "print_color"
.Vb 1
\&  print_color "red bold";
.Ve
.PP
\&\f(CWprint_color()\fR takes one or more ANSI colors and prints, provided that the
\&\f(CW\*(C`NOCOLOR\*(C'\fR setting is \f(CW\*(C`FALSE\*(C'\fR. See the \f(CW\*(C`Function Interface\*(C'\fR section in
\&\f(CWTerm::ANSIColor(3)\fR for a list of available colors.
.PP
Using colors \f(CW\*(C`black\*(C'\fR through \f(CW\*(C`bright_white\*(C'\fR, \f(CW\*(C`bold\*(C'\fR and \f(CW\*(C`reset\*(C'\fR only is
advisable to ensure terminal compatibility. When calling \f(CWprint_color()\fR before
exiting, ensure that a new line follows to avoid an improper cursor on some
terminals.
.PP
There is no useful return value.
.SS print_failures
.IX Subsection "print_failures"
.Vb 1
\&  print_failures($failures);
.Ve
.PP
\&\f(CWprint_failures()\fR prints all failures in the \f(CW$failures\fR array reference
to STDERR, if any.
.PP
There is no useful return value.
.SS prompt
.IX Subsection "prompt"
.Vb 1
\&  exit unless prompt $color_notice, "Should we continue?", default => "yes";
.Ve
.PP
\&\f(CWprompt()\fR prompts the user for an answer, optionally specifying a default of
\&\f(CW\*(C`yes\*(C'\fR or \f(CW\*(C`no\*(C'\fR.
.PP
If the default has been specified, it returns a true value for \*(Aqyes\*(Aq and a false
one for \*(Aqno\*(Aq. Otherwise, it returns the content of the user\*(Aqs answer.
.PP
Output is wrapped at 72 characters.
.SS read_config
.IX Subsection "read_config"
.Vb 1
\&  read_config();
.Ve
.PP
\&\f(CWread_config()\fR reads in the configuration settings from
\&\f(CW\*(C`/etc/sbotools/sbotools.conf\*(C'\fR, updating the \f(CW%config\fR hash. If
\&\f(CW\*(C`SBO_HOME\*(C'\fR is \f(CW\*(C`FALSE\*(C'\fR, it changes to \f(CW\*(C`/usr/sbo\*(C'\fR.
Additionally, \f(CW\*(C`BUILD_IGNORE\*(C'\fR, \f(CW\*(C`RSYNC_DEFAULT\*(C'\fR and \f(CW\*(C`NOCOLOR\*(C'\fR
are turned on if \f(CW\*(C`CLASSIC\*(C'\fR is \f(CW\*(C`TRUE\*(C'\fR.
.PP
When \f(CW\*(C`sbotest\*(C'\fR is running, the default value of \f(CW\*(C`SBO_HOME\*(C'\fR
is \f(CW\*(C`/usr/sbotest\*(C'\fR, and \f(CW\*(C`ETC_PROFILE\*(C'\fR and \f(CW\*(C`CPAN_IGNORE\*(C'\fR default
to \f(CW\*(C`TRUE\*(C'\fR. Supplementary setting \f(CW\*(C`SBO_ARCHIVE\*(C'\fR defaults to
\&\f(CW\*(C`/usr/sbotest/archive\*(C'\fR. \f(CW\*(C`PKG_DIR\*(C'\fR and \f(CW\*(C`LOG_DIR\*(C'\fR default to
\&\f(CW\*(C`/usr/sbotest/tests\*(C'\fR and \f(CW\*(C`/usr/sbotest/logs\*(C'\fR, respectively, but
\&\f(CW\*(C`sbotest\*(C'\fR uses timestamped directories under the configured paths.
.PP
There is no useful return value.
.SS read_hints
.IX Subsection "read_hints"
.Vb 1
\&  our @listings = read_hints();
.Ve
.PP
\&\f(CWread_hints()\fR reads the contents of /etc/sbotools/sbotools.hints, returning an array
of optional dependency requests and blacklisted scripts. \f(CWread_hints()\fR is used to
populate global array \f(CW@listings\fR, and should only be called at the start and again
when editing the hints file.
.SS reconcile_time
.IX Subsection "reconcile_time"
.Vb 1
\&  my $corrected_seconds = reconcile_time($seconds);
.Ve
.PP
\&\f(CWreconcile_time()\fR takes a duration in seconds (integer or otherwise) and subtracts
any time spent stopped from keyboard signal. It returns the corrected number of seconds.
.SS save_options
.IX Subsection "save_options"
.Vb 1
\&  save_options($sbo, $opts)
.Ve
.PP
\&\f(CWsave_options()\fR saves build options to \f(CW\*(C`/var/log/sbotools/sbo\*(C'\fR. For \f(CW\*(C`compat32\*(C'\fR
packages, the file for the base script is used. If the file already exists and the
user supplies no build options, the existing file is retained.
.SS script_error
.IX Subsection "script_error"
.Vb 2
\&  script_error();
\&  script_error($msg);
.Ve
.PP
\&\fBscript_error()\fR warns and exits with code _ERR_SCRIPT, printing the following to STDERR:
.PP
.Vb 1
\&  A fatal script error has occurred. Exiting.
.Ve
.PP
If a \f(CW$msg\fR was supplied, it instead prints:
.PP
.Vb 3
\&  A fatal script error has occurred:
\&  $msg.
\&  Exiting.
.Ve
.PP
There is no useful return value. For _ERR_USAGE, use \f(CWusage_error()\fR. For other error
codes, use \f(CWerror_code()\fR.
.SS show_version
.IX Subsection "show_version"
.Vb 1
\&  show_version();
.Ve
.PP
\&\f(CWshow_version()\fR prints the sbotools version and licensing information
to STDOUT.
.PP
There is no useful return value.
.SS slurp
.IX Subsection "slurp"
.Vb 1
\&  my $data = slurp($fn);
.Ve
.PP
\&\f(CWslurp()\fR takes a filename in \f(CW$fn\fR, opens it, and reads in the entire file.
The contents are then returned. On error, it returns \f(CW\*(C`undef\*(C'\fR.
.SS time_format
.IX Subsection "time_format"
.Vb 1
\&  my $time_string = time_format($time);
.Ve
.PP
\&\f(CWtime_format()\fR takes a number of seconds (integer or otherwise) and returns
a string H:MM:SS.
.SS uniq
.IX Subsection "uniq"
.Vb 1
\&  my @uniq = uniq(@duplicates);
.Ve
.PP
\&\f(CWuniq()\fR removes any duplicates from \f(CW@duplicates\fR, otherwise returning the
list in the same order.
.SS usage_error
.IX Subsection "usage_error"
.Vb 1
\&  usage_error($msg);
.Ve
.PP
\&\f(CWusage_error()\fR warns and exits with code _ERR_USAGE, printing \f(CW$msg\fR to STDERR.
Error messages wrap at 72 characters.
.PP
There is no useful return value. For _ERR_SCRIPT, use \f(CWscript_error()\fR; for other
error codes, use \f(CWerror_code()\fR.
.SS version_cmp
.IX Subsection "version_cmp"
.Vb 1
\&  my $cmp = version_cmp($ver1, $ver2);
.Ve
.PP
\&\f(CWversion_cmp()\fR compares \f(CW$ver1\fR with \f(CW$ver2\fR. It returns 1 if \f(CW$ver1\fR is higher,
\&\-1 if \f(CW$ver2\fR is higher and 0 if they are equal. It strips the running kernel version,
as well as any locale information that may have been appended to the version strings.
.SS warn_color
.IX Subsection "warn_color"
.Vb 1
\&  warn_color($color, $msg);
.Ve
.PP
\&\f(CWwarn_color()\fR emits a warning in the chosen color and resets the color
afterwards. No colors are used if \f(CW\*(C`NOCOLOR\*(C'\fR is \f(CW\*(C`TRUE\*(C'\fR. A newline is added
automatically after the message. There is no useful return value.
.SS wrapsay
.IX Subsection "wrapsay"
.Vb 1
\&  wrapsay($msg, $trail);
.Ve
.PP
\&\f(CWwrapsay()\fR outputs a message with the lines wrapped at 72 characters and
a trailing newline. There is no useful return value. Optional \f(CW$trail\fR
outputs an extra newline if present.
.PP
Use this subroutine whenever it is either obvious that the output exceeds
80 characters or the output includes a variable. \f(CW\*(C`say\*(C'\fR can be used in
other cases. \f(CWwrapsay()\fR should not be used on output that can be piped
for use in scripts (e.g., queue reports from \f(CWsbofind(1)\fR).
.SS wrapsay_color
.IX Subsection "wrapsay_color"
.Vb 1
\&  wrapsay_color($color, $msg, $trail);
.Ve
.PP
\&\f(CWwrapsay_color()\fR takes a color, a message and any true value if a trailing line
is required. It applies a color, runs the message through \f(CWwrapsay()\fR and
resets the color afterwards. No colors are used if \f(CW\*(C`NOCOLOR\*(C'\fR is \f(CW\*(C`TRUE\*(C'\fR. There
is no useful return value.
.SH "EXIT CODES"
.IX Header "EXIT CODES"
The sbotools share the following exit codes:
.PP
.Vb 10
\&  _ERR_USAGE         1   usage errors
\&  _ERR_SCRIPT        2   script or module bug
\&  _ERR_BUILD         3   errors when executing a SlackBuild
\&  _ERR_MD5SUM        4   download verification failure
\&  _ERR_DOWNLOAD      5   download failure
\&  _ERR_OPENFH        6   failure to open file handles
\&  _ERR_NOINFO        7   missing download information
\&  _ERR_F_SETD        8   fd\-related temporary file failure
\&  _ERR_NOMULTILIB    9   lacking multilib capabilities when needed
\&  _ERR_CONVERTPKG    10  convertpkg\-compat32 failure
\&  _ERR_NOCONVERTPKG  11  lacking convertpkg\-compat32 when needed
\&  _ERR_INST_SIGNAL   12  the script was interrupted while building
\&  _ERR_CIRCULAR      13  attempted to calculate a circular dependency
\&  _ERR_USR_GRP       14  a required user or group is missing
\&  _ERR_GPG           15  GPG verification failed
\&  _ERR_STDIN         16  reading keyboard input failed
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fBSBO::Lib\fR\|(3), \fBSBO::Lib::Build\fR\|(3), \fBSBO::Lib::Download\fR\|(3), \fBSBO::Lib::Info\fR\|(3), \fBSBO::Lib::Pkgs\fR\|(3), \fBSBO::Lib::Readme\fR\|(3), \fBSBO::Lib::Repo\fR\|(3), \fBSBO::Lib::Tree\fR\|(3), \fBTerm::ANSIColor\fR\|(3)
.SH AUTHORS
.IX Header "AUTHORS"
SBO::Lib was originally written by Jacob Pipkin <j@dawnrazor.net> with
contributions from Luke Williams <xocel@iquidus.org> and Andreas
Guldstrand <andreas.guldstrand@gmail.com>.
.SH MAINTAINER
.IX Header "MAINTAINER"
SBO::Lib is maintained by K. Eugene Carlson <kvngncrlsn@gmail.com>.
.SH LICENSE
.IX Header "LICENSE"
The sbotools are licensed under the MIT License.
.PP
Copyright (C) 2012\-2017, Jacob Pipkin, Luke Williams, Andreas Guldstrand.
.PP
Copyright (C) 2024\-2025, K. Eugene Carlson.
