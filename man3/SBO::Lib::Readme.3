.\" -*- mode: troff; coding: utf-8 -*-
.\" Automatically generated by Pod::Man 5.0102 (Pod::Simple 3.45)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" \*(C` and \*(C' are quotes in nroff, nothing in troff, for use with C<>.
.ie n \{\
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "SBO::Lib::Readme 3"
.TH SBO::Lib::Readme 3 "Prickle-Prickle, The Aftermath 57, 3190 YOLD" "" "sbotools 3.1"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH NAME
SBO::Lib::Readme \- Routines for interacting with a typical SBo README file.
.SH SYNOPSIS
.IX Header "SYNOPSIS"
.Vb 1
\&  use SBO::Lib::Readme qw/ get_readme_contents /;
\&
\&  print get_readme_contents($sbo);
.Ve
.SH SUBROUTINES
.IX Header "SUBROUTINES"
.SS ask_opts
.IX Subsection "ask_opts"
.Vb 1
\&  my $opts = ask_opts($sbo, $readme);
.Ve
.PP
\&\f(CWask_opts()\fR displays the \f(CW$readme\fR and asks if we should set any of the
options it defines. If the user indicates that we should, we prompt them for
the options to set and then returns them as a string. If the user didn't supply
any options or indicated that we shouldn't, it returns \f(CW\*(C`undef\*(C'\fR. In addition,
if options were previously set by the user, they are retrieved and can be used
again.
.SS ask_other_readmes
.IX Subsection "ask_other_readmes"
.Vb 1
\&  ask_other_readmes($sbo, $location);
.Ve
.PP
\&\f(CWask_other_readmes()\fR checks if there are other readmes for the \f(CW$sbo\fR in
\&\f(CW$location\fR, and if so, asks the user if they should be displayed, and then
displays them if the user didn't decline.
.SS ask_user_group
.IX Subsection "ask_user_group"
.Vb 1
\&  my $bool = ask_user_group($cmds, $readme);
.Ve
.PP
\&\f(CWask_user_group()\fR displays the \f(CW$readme\fR and commands found in \f(CW$cmds\fR, and
asks the user if we should automatically run the \f(CW\*(C`useradd\*(C'\fR/\f(CW\*(C`/groupadd\*(C'\fR
commands found. If the user indicates that we should, it returns the \f(CW$cmds\fR,
otherwise it returns \f(CW\*(C`undef\*(C'\fR.
.SS get_opts
.IX Subsection "get_opts"
.Vb 1
\&  my $bool = get_opts($readme);
.Ve
.PP
\&\f(CWget_opts()\fR checks if the \f(CW$readme\fR has any options defined, and if so
returns a true value. Otherwise it returns a false value.
.SS get_readme_contents
.IX Subsection "get_readme_contents"
.Vb 1
\&  my $contents = get_readme_contents($location);
.Ve
.PP
\&\f(CWget_readme_contents()\fR will open the README file in \f(CW$location\fR and return
its contents. On error, it will return \f(CW\*(C`undef\*(C'\fR.
.SS get_user_group
.IX Subsection "get_user_group"
.Vb 1
\&  my @cmds = @{ get_user_group($readme) };
.Ve
.PP
\&\f(CWget_user_group()\fR searches through the \f(CW$readme\fR for \f(CW\*(C`useradd\*(C'\fR and
\&\f(CW\*(C`groupadd\*(C'\fR commands, and returns them in an array reference.
.SS user_prompt
.IX Subsection "user_prompt"
.Vb 1
\&  my ($cmds, $opts, $exit) = user_prompt($sbo, $location);
.Ve
.PP
\&\f(CWuser_prompt()\fR checks for options and commands, to see if we should run them,
and asks if we should proceed with the \f(CW$sbo\fR in question.
.PP
It returns a list of three values, and if the third one is a true value, the
first indicates an error message. Otherwise, the first value will either be an
\&\f(CW\*(AqN\*(Aq\fR, \f(CW\*(C`undef\*(C'\fR, or an array reference. If it's \f(CW\*(AqN\*(Aq\fR, the user indicated
that we should \fBnot\fR build this \f(CW$sbo\fR. Otherwise it indicates if we should
run any \f(CW\*(C`useradd\*(C'\fR/\f(CW\*(C`groupadd\*(C'\fR commands, or if it's \f(CW\*(C`undef\*(C'\fR, that we
shouldn't. The second return value indicates the options we should specify if
we build this \f(CW$sbo\fR.
.PP
\&\fBNote\fR: This should really be changed.
.SH AUTHORS
.IX Header "AUTHORS"
SBO::Lib was originally written by Jacob Pipkin <j@dawnrazor.net> with
contributions from Luke Williams <xocel@iquidus.org> and Andreas
Guldstrand <andreas.guldstrand@gmail.com>.
.PP
SBO::Lib is maintained by K. Eugene Carlson <kvngncrlsn@gmail.com>.
.SH LICENSE
.IX Header "LICENSE"
The sbotools are licensed under the MIT License.
.PP
Copyright (C) 2012\-2017, Jacob Pipkin, Luke Williams, Andreas Guldstrand.
Copyright (C) 2024, K. Eugene Carlson.
