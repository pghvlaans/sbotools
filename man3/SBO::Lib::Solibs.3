.\" -*- mode: troff; coding: utf-8 -*-
.\" Automatically generated by Pod::Man v6.0.2 (Pod::Simple 3.45)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" \*(C` and \*(C' are quotes in nroff, nothing in troff, for use with C<>.
.ie n \{\
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Required to disable full justification in groff 1.23.0.
.if n .ds AD l
.\" ========================================================================
.\"
.IX Title "SBO::Lib::Solibs 3"
.TH SBO::Lib::Solibs 3 "Boomtime, Bureaucracy 73, 3191 YOLD" "" "sbotools 4.0"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH NAME
SBO::Lib::Solibs \- Routines for evaluating ELF binaries and checking compatibility
.SH SYNOPSIS
.IX Header "SYNOPSIS"
.Vb 1
\&  use SBO::Lib::Solibs qw/ solib_check /;
.Ve
.SH VARIABLES
.IX Header "VARIABLES"
.ie n .SS @native_libs
.el .SS \f(CW@native_libs\fP
.IX Subsection "@native_libs"
An array with shared objects (solibs) of the native architecture in the \f(CWldconfig(1)\fR cache.
It is generated by \f(CWsolib_check()\fR via \f(CWupdate_known_solibs()\fR if it is empty at the time
of calling.
.ie n .SS %old_libs
.el .SS \f(CW%old_libs\fP
.IX Subsection "%old_libs"
A hash with a per\-package list of apparently missing first\-order shared object dependencies;
each missing dependency comes with a list of files that link to it. This hash is generated
when running \f(CWsolib_check()\fR.
.ie n .SS "%per_cand, %x86_per_cand"
.el .SS "\f(CW%per_cand\fP, \f(CW%x86_per_cand\fP"
.IX Subsection "%per_cand, %x86_per_cand"
Hashes with per\-object lists of dynamically\-linked files. They are used to produce the file lists
in \f(CW%old_libs\fR, and are not exported.
.ie n .SS @x86_libs
.el .SS \f(CW@x86_libs\fP
.IX Subsection "@x86_libs"
An array with 32\-bit shared objects in the \f(CWldconfig(1)\fR cache. Used only under the
\&\f(CW\*(C`x86_64\*(C'\fR architecture, it is generated together with \f(CW@native_libs\fR by \f(CWupdate_known_solibs()\fR.
.SH SUBROUTINES
.IX Header "SUBROUTINES"
.SS decimalize
.IX Subsection "decimalize"
.Vb 1
\&  my $decimal = decimalize($hex, $big_endian);
.Ve
.PP
\&\f(CWdecimalize()\fR takes a hex string and an indicator of whether big\-endian processing is to be
used, returning a decimal string.
.SS elf_links
.IX Subsection "elf_links"
.Vb 1
\&  my ($elf_type, @cand_libs) = is_elf($file);
.Ve
.PP
\&\f(CWelf_links()\fR takes a path and checks whether it is a dynamically\-linked ELF binary; it
returns 0 if not. Otherwise, it reads entries according to the \fBelf\fR\|(5) specification and
returns 1 for a 64\-bit ELF file, \-1 for a 32\-bit ELF file and an array of first\-order
shared object dependencies that do not exist on the system under an \f(CW\*(C`rpath\*(C'\fR or \f(CW\*(C`runpath\*(C'\fR.
.SS installed_solibs
.IX Subsection "installed_solibs"
.Vb 1
\&  my @pkg_solibs = installed_solibs($pkg);
.Ve
.PP
\&\f(CWinstalled_solibs()\fR takes the name of a package file. It returns an array of
shared object names that are installed as files or symlinks, or 0 if none exist.
.SS series_check
.IX Subsection "series_check"
.Vb 1
\&  my @series_good = series_check($pkg, @series);
.Ve
.PP
\&\f(CWseries_check()\fR takes the name of a package file and an array with one or more checks
to perform. Available checks include \f(CW\*(C`perl\*(C'\fR, \f(CW\*(C`python\*(C'\fR and \f(CW\*(C`ruby\*(C'\fR at this time. \f(CW\*(C`python\*(C'\fR
and \f(CW\*(C`ruby\*(C'\fR are judged to be incompatible if files associated with the wrong major version
(e.g. \f(CW\*(C`python\-3.12\*(C'\fR or \f(CW\*(C`ruby\-3.4*\*(C'\fR) are included. \f(CW\*(C`perl\*(C'\fR packages are flagged if any
library in \f(CW\*(C`/usr/lib*/perl*\*(C'\fR was built before the system \f(CW\*(C`perl\*(C'\fR package was installed.
.PP
The subroutine returns an array with results for the three checks in alphabetical order,
with 1 indicating apparent compatibility and 0 indicating apparent incompatibility.
.SS solib_check
.IX Subsection "solib_check"
.Vb 1
\&  my $solibs_good = solib_check($pkg);
\&
\&  my $solibs_good = solib_check($pkg, @search);
.Ve
.PP
\&\f(CWsolib_check()\fR takes the name of a package file and, optionally, an array of shared
object names to search, and checks for the presence of any required first\-order shared
object dependencies as based on the \f(CW@native_libs\fR shared object array. It returns 1 if
all required shared objects appear to be present and 0 otherwise.
.PP
Because \f(CWelf_links()\fR is called, performance is cache\-dependent. It is best to call
\&\f(CWsolib_check()\fR judiciously.
.SS solib_present
.IX Subsection "solib_present"
.Vb 1
\&  my $solib_present = solib_present($cand_lib, $pkg, @candidate_files);
.Ve
.PP
\&\f(CWsolib_present()\fR takes the name of the shared object to be checked, the name of
a package file and an array with probable ELF files shipped by that package. It returns 1 if
the shared object appears to be present and 0 if it does not.
.PP
Please note that the known shared object array \f(CW@native_libs\fR (and \f(CW@x86_libs\fR if running
on the \f(CW\*(C`x86_64\*(C'\fR architecture) is the main source of shared object verification.
\&\f(CWsolib_present()\fR is called after this first verification step fails. Shared objects
that are neither shipped nor created as symlinks by the package can be missed.
.PP
This subroutine is not exported.
.SS update_known_solibs
.IX Subsection "update_known_solibs"
.Vb 1
\&  update_known_solibs;
.Ve
.PP
\&\f(CWupdate_known_solibs()\fR takes no arguments. It uses the \f(CW\*(C`\-\-print\-cache\*(C'\fR option of
\&\f(CWldconfig(1)\fR to generate an array of existent known shared objects, \f(CW@native_libs\fR. On
\&\f(CW\*(C`x86_64\*(C'\fR systems, it generates \f(CW@x86_libs\fR as well, an array with 32\-bit shared objects.
.PP
The script exits in case of \f(CW\*(C`ldcdonfig\*(C'\fR failure. There is no useful return value.
.SH "EXIT CODES"
.IX Header "EXIT CODES"
Solibs.pm subroutines can return the following exit codes:
.PP
.Vb 2
\&  _ERR_SCRIPT        2   script or module bug
\&  _ERR_OPENFH        6   failure to open file handles
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fBSBO::Lib\fR\|(3), \fBSBO::Lib::Build\fR\|(3), \fBSBO::Lib::Download\fR\|(3), \fBSBO::Lib::Info\fR\|(3), \fBSBO::Lib::Pkgs\fR\|(3), \fBSBO::Lib::Readme\fR\|(3), \fBSBO::Lib::Repo\fR\|(3), \fBSBO::Lib::Tree\fR\|(3), \fBSBO::Lib::Util\fR\|(3), \fBelf\fR\|(5), \fBldconfig\fR\|(1)
.PP
In addition to the man page, \f(CW\*(C`https://refspecs.linuxbase.org/elf/gabi4+/\*(C'\fR is a helpful
resource about the structure of ELF files.
.SH AUTHORS
.IX Header "AUTHORS"
SBO::Lib was originally written by Jacob Pipkin <j@dawnrazor.net> with
contributions from Luke Williams <xocel@iquidus.org> and Andreas
Guldstrand <andreas.guldstrand@gmail.com>.
.SH MAINTAINER
.IX Header "MAINTAINER"
SBO::Lib is maintained by K. Eugene Carlson <kvngncrlsn@gmail.com>.
.SH LICENSE
.IX Header "LICENSE"
The sbotools are licensed under the MIT License.
.PP
Copyright (C) 2012\-2017, Jacob Pipkin, Luke Williams, Andreas Guldstrand.
.PP
Copyright (C) 2024\-2025, K. Eugene Carlson.
